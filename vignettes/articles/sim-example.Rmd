---
title: "Early outbreak and Generation time"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Early outbreak and Generation time}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}

---

```{r setup, include=FALSE}

# bibliography: ../references.bib
# link-citations: TRUE

options(
  repos = c(
    "ai4ci" = 'https://ai4ci.r-universe.dev/',
    "terminological" = 'https://terminological.r-universe.dev/',
    CRAN = 'https://cloud.r-project.org'
  )
)

future::plan(future::multisession, workers = parallel::detectCores()-2)

library(tidyverse)
library(tidyabc)

knitr::opts_chunk$set(
  echo = TRUE,
  dev = "ragg_png"
)

```


# Simulation

## Setup simulation

```{r}
sim_params = list(
  # A short generation time
  mean_gt = 4,
  sd_gt = 2,
  R0 = 2,
  I0 = 10,
  # Add a longish and very variable delay to symptoms
  p_symptomatic = 0.3,
  mean_onset = 7,
  sd_onset = 5,
  # and a slightly shorter delay to observation:
  # Only symptomatic cases are observed
  p_detected_given_symptoms = 0.7,
  mean_obs = 5,
  sd_obs = 3,
  # Observation cutoff:
  T_obs = 40
)

# Run simulation ----

sim_ip = ggoutbreak::make_gamma_ip(
  median_of_mean = sim_params$mean_gt,
  median_of_sd = sim_params$sd_gt
)

sim_params$r0 = ggoutbreak::inv_wallinga_lipsitch(sim_params$R0, sim_ip)

truth = ggoutbreak::sim_branching_process(
  fn_Rt = ~ sim_params$R0,
  fn_ip = ~sim_ip,
  fn_imports = \(t) ifelse(t == 1, sim_params$I0, 0),
  max_time = 40
)

delayed = truth %>%
  ggoutbreak::sim_delay(
    p_fn = ~ sim_params$p_symptomatic,
    delay_fn = ~ ggoutbreak::rgamma2(
      .x,
      sim_params$mean_onset,
      sim_params$sd_onset
    ),
    input = "time",
    output = "symptom"
  ) %>%
  ggoutbreak::sim_delay(
    p_fn = \(t, symptom) {
      ifelse(symptom, sim_params$p_detected_given_symptoms, 0)
    },
    delay_fn = ~ ggoutbreak::rgamma2(
      .x,
      sim_params$mean_obs,
      sim_params$sd_obs
    ),
    input = "symptom_time",
    output = "observation"
  )


observed = delayed %>% dplyr::filter(observation_time < sim_params$T)

traced_contacts = observed %>%
  dplyr::semi_join(observed, by = c("infector" = "id"))
```

## Index case onset

```{r}
index_case_onset = observed %>% dplyr::transmute(onset_time = floor(symptom_time))

ggplot(index_case_onset, aes(x=onset_time))+geom_histogram(binwidth = 1)
```

## Delay to observation

```{r}

# Data

delay_distribution = observed %>% dplyr::transmute(
  obs_delay = floor(observation_time) - floor(symptom_time)
)

ggplot(delay_distribution, aes(x = obs_delay))+geom_histogram(binwidth = 1)+
  xlab("symptom to observation")
```

## Observed serial interval

```{r}
serial_pairs = observed %>%
  inner_join(
    traced_contacts,
    by = c("id" = "infector"),
    suffix = c(".1", ".2")
  ) %>%
  transmute(
    serial_interval = floor(symptom_time.2) - floor(symptom_time.1) #order known
    # serial_interval = abs(floor(symptom_time.2) - floor(symptom_time.1)) #order uncertain
  ) 



ggplot(serial_pairs) +
  geom_histogram(aes(x = serial_interval), binwidth = 1)+
  xlab("symptom serial interval (given observed)")
```

```{r}
obsdata = list(
  onset = as.numeric(index_case_onset$onset_time),
  diff = as.numeric(delay_distribution$obs_delay),
  si = as.numeric(serial_pairs$serial_interval)
)
```






# Model

Aim is to fit a model to all 3 aspects of the data simultaneously. 
The model makes the following hard assumptions:

- constant exponential growth in infection times (hidden t_inf)
- delayed onset to symptoms - gamma distributed (t_onset = t_inf + onset_delay)
- delayed observation of symptoms - gamma distributed (t_obs = onset + obs_delay)
- secondary case delayed by generation time (hidden t_inf2 = t_inf + gt_delay)
- secondary case symptom onset and observation as above (t_onset_2 / t_obs_2)
- cases only observed if t_obs / t_obs_2 within time window (0-T)

$$
\begin{align}
t_{max} - T_{inf} &\sim Exp(r_0) \\
\Delta T_{inf \rightarrow onset} &\sim Gamma(\mu_{onset},\sigma_{onset}) \\
\Delta T_{onset \rightarrow obs} &\sim Gamma(\mu_{obs},\sigma_{obs}) \\
\Delta T_{gt} &\sim Gamma(\mu_{gt},\sigma_{gt}) \\
\end{align}
$$

$$
\begin{align}
T_{onset} &= T_{inf} + \Delta T_{inf \rightarrow onset} \\
T_{obs} &= T_{onset} + \Delta T_{onset \rightarrow obs}\\
T_{inf_2} &= T_{inf_1} + \Delta T_{gt} \\
\Delta T_{onset_1 \rightarrow onset_2} &=  \Delta T_{gt} + \Delta T_{inf_2 \rightarrow onset_2} -  \Delta T_{inf_1 \rightarrow onset_1} \\
\end{align}
$$


$$
\begin{align}
O_1 &= I(t_0 \le T_{onset_1}, T_{obs_1} \le t_{max}) \\
O_{1,2} &= I(O_1, t_0 \le T_{onset_2}, T_{obs_2} \le t_{max})\\
T_{onset_1}|O_1 &\Rightarrow \text{primary case times}\\
\Delta T_{onset_1 \rightarrow obs_1}|O_1 &\Rightarrow \text{onset to interview delay}\\
\Delta T_{onset_1 \rightarrow onset_2}|O_{1,2} &\Rightarrow \text{onset to onset serial interval}\\
\end{align}
$$

```{r}
n = nrow(observed)

sim1_fn = carrier::crate(
  function(r0, mean_onset, sd_onset, mean_obs, sd_obs, mean_gt, sd_gt, R0, ...) {
    
    # Primary case infection time
    # exponentially distributed in time. Need to make sure we have enough samples 
    # before t0 observation cutoff to account for early observed cases.
    
    t_early = - stats::qgamma(0.99,mean_onset,sd_onset) # t starts at 0
    t_inf_1 = tidyabc::rexpgrowth(n, r0, T_obs, t_early)
    
    onset_delay = tidyabc::rgamma2(n, mean_onset, sd_onset)
    obs_delay = tidyabc::rgamma2(n, mean_obs, sd_obs)
    
    t_onset_1 = t_inf_1 + onset_delay
    t_obs_1 = t_onset_1 + obs_delay
    
    # Primary case observations:
    # Onset after t0 and observed before T
    obs_1 = t_obs_1 < T_obs & t_onset_1 > 0
    
    t_inf_1 = t_inf_1[obs_1]
    t_onset_1 = t_onset_1[obs_1]
    t_obs_1 = t_obs_1[obs_1]
    
    n1 = length(t_inf_1)
    
    # Secondary case. Numbers of secondary cases are poission(R0). Could add 
    # dispersion here and fit it also
    # Only observed primary will be observed secondary so we can restrict to 
    # observed subset
    # browser()
    case_2ary = stats::rpois(n1,R0)
    index_1ary = rep(seq_along(case_2ary), case_2ary)
    n2 = length(index_1ary)
    
    gt_delay = tidyabc::rgamma2(n2, mean_gt, sd_gt)
    onset_delay_2 = tidyabc::rgamma2(n2, mean_onset, sd_onset)
    obs_delay_2 = tidyabc::rgamma2(n2, mean_obs, sd_obs)
    
    t_inf_2 = t_inf_1[index_1ary] + gt_delay
    t_onset_2 = t_inf_2 + onset_delay_2
    t_obs_2 = t_onset_2 + obs_delay_2
    
    # order dependent
    serial_interval = floor(t_onset_2) - floor(t_onset_1[index_1ary])
    # order independent
    # serial_interval = abs(floor(t_onset_2) - floor(t_onset_1[index_1ary]))
    
    # Secondary case observations
    obs_2 = t_obs_2 < T_obs & t_onset_2 > 0
    
    serial_interval = serial_interval[obs_2]
    t_onset_2 = t_onset_2[obs_2]
    
    return(list(
      onset = floor(t_onset_1),
      diff = floor(t_obs_1) - floor(t_onset_1),
      si = serial_interval
    ))
  },
  T_obs = sim_params$T_obs,
  n=n
)
```


```{r}

scorer1_fn = function(simdata, obsdata) {
  
  onset = calculate_wasserstein(obsdata$onset, simdata$onset)
  diff = calculate_wasserstein(obsdata$diff, simdata$diff)
  si = calculate_wasserstein(obsdata$si, simdata$si)
  mad_si = abs(mean(obsdata$si) - mean(simdata$si))
  
  return(list(
    sim_onset = onset,
    sim_diff = diff,
    sim_si=si,
    sim_mad_si = mad_si
  ))
}

# make the serial interval fitting much more important:
scoreweights1 = c(
    sim_onset = 2,
    sim_diff = 0.5,
    sim_si = 3,
    sim_mad_si = 3
  )

```


```{r}

test = tidyabc::test_simulation(
  sim_fn = sim1_fn, 
  scorer_fn = scorer1_fn,
  params = sim_params,
  obsdata = obsdata
  # debug=TRUE
)

# .gg_hist(test$obsdata$onset)

```

## Scoring

We are going to fit the model in a custom ABC with rejection framework

I'm assessing model fits to the data using an earth movers distance at the
level of individual's observed times versus simulations observed times. Given 
that simulations cutoff different numbers of people I have to match the size
of the simulation and observed data


## Priors

Use a set of uninformative priors. RO is derived from Wallinga-Lipsitch, Gamma
distributions hyperparameters constrained so that they are convex:

```{r}

priors = priors(
  r0 ~ unif(-0.1, 0.7),
  mean_onset ~ unif(0, 12),
  sd_onset ~ unif(0, 8),
  mean_obs ~ unif(0, 12),
  sd_obs ~ unif(0, 8),
  mean_gt ~ unif(0, 12),
  sd_gt ~ unif(0, 8),
  R0 ~ (1+r0*sd_gt^2/mean_gt) ^ (mean_gt^2 / sd_gt^2),
  ~ is.finite(R0) & R0 > 0,
  ~ mean_onset > sd_onset,
  ~ mean_obs > sd_obs,
  ~ mean_gt > sd_gt
)

priors
```


```{r}

abc_fit = abc_rejection(
  obsdata = obsdata,
  priors_list = priors,
  sim_fn = sim1_fn,
  scorer_fn = scorer1_fn,
  n_sims = 1000000,
  acceptance_rate = 0.001,
  parallel = TRUE,
  scoreweights = scoreweights1
)

summary(abc_fit)
plot(abc_fit, truth = sim_params)

```


```{r}

smc_fit = abc_smc(
  obsdata = obsdata,
  priors_list = priors,
  sim_fn = sim1_fn,
  scorer_fn = scorer1_fn,
  n_sims = 8000,
  acceptance_rate = 0.5,
  #debug_errors = TRUE,
  parallel = TRUE,
  scoreweights = scoreweights1
)

summary(smc_fit)

```

```{r}
plot(smc_fit,truth = sim_params)
plot_evolution(smc_fit,truth = sim_params)
```

```{r}


adaptive_fit = abc_adaptive(
  obsdata = obsdata,
  priors_list = priors,
  sim_fn = sim1_fn,
  scorer_fn = scorer1_fn,
  n_sims = 4000,
  acceptance_rate = 0.5,
  # debug_errors = TRUE,
  parallel = TRUE,
  scoreweights = scoreweights1
)

summary(adaptive_fit)

```



```{r}

plot(adaptive_fit,truth = sim_params)
plot_evolution(adaptive_fit,truth = sim_params)
plot_correlations(adaptive_fit,truth = sim_params) & ggplot2::theme(
   axis.title.y = ggplot2::element_text(angle=70,vjust=0.1)
)
plot_convergence(adaptive_fit)
plot_simulations(obsdata, adaptive_fit, sim_fn = sim1_fn)
```


```{r}

priors2 = priors(
  r0 ~ unif(-0.1, 0.7),
  mean_onset ~ lnorm2(7, 2),
  sd_onset ~ lnorm2(5, 1),
  mean_obs ~ lnorm2(5, 1),
  sd_obs ~ lnorm2(3, 1),
  mean_gt ~ unif(0, 12),
  sd_gt ~ unif(0, 8),
  R0 ~ (1+r0*sd_gt^2/mean_gt) ^ (mean_gt^2 / sd_gt^2),
  ~ is.finite(R0) & R0 > 0,
  ~ mean_onset > sd_onset,
  ~ mean_obs > sd_obs,
  ~ mean_gt > sd_gt
)

priors2
```


```{r}


adaptive_fit2 = abc_adaptive(
  obsdata = obsdata,
  priors_list = priors2,
  sim_fn = sim1_fn,
  scorer_fn = scorer1_fn,
  n_sims = 4000,
  acceptance_rate = 0.5,
  # debug_errors = TRUE,
  parallel = TRUE,
  scoreweights = scoreweights1
)

summary(adaptive_fit2)

```
```{r}

plot(adaptive_fit2,truth = sim_params)
plot_evolution(adaptive_fit2,truth = sim_params)
plot_correlations(adaptive_fit2,truth = sim_params)
plot_convergence(adaptive_fit2)
plot_simulations(obsdata, adaptive_fit2, sim_fn = sim1_fn)
```