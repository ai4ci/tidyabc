#' Increase the dispersion of a distribution
#'
#' Increases the dispersion (spread) of a distribution by transforming its
#' quantile function in a standardized Q-Q space.
#'
#' The transformation aims to increase the standard deviation by a factor
#' `scale` while preserving the median. It operates on the
#' internal Q-Q space representation (`qx`, `qy`) of an empirical distribution
#' generated by `empirical_cdf`.
#'
#' Applies a logit-space scaling transformation centred on the median quantile.
#' This transformation modifies the quantile axis (`qx`) in the Q-Q space of an
#' empirical distribution to change its dispersion while preserving the median
#' value.
#'
#' Let `qx` be the original quantile coordinate in `[0, 1]`, and `qmedian` be the
#' quantile corresponding to the median (e.g., `qx_from_qy(0.5)`). The transformation
#' is defined as:
#'
#' \deqn{
#'   qx_2 = \text{expit}\left( (\text{logit}(qx) - \text{logit}(qmedian)) \times \text{scale} + \text{logit}(qmedian) \right)
#' }
#'
#' where \eqn{\text{logit}(x) = \log(x / (1 - x))} and \eqn{\text{expit}(x) = 1 / (1 + \exp(-x))}
#' are the standard logit and inverse-logit functions, respectively.
#'
#'
#' @param x a distribution as a `dist_fns` S3 object
#' @param scale acts as a multiplier for the log-odds difference from the
#' median, effectively acting like an odds-ratio parameter. A `scale > 1` increases
#' dispersion (stretches quantiles away from the median in logit space), while
#' `0 < scale < 1` decreases dispersion (compresses quantiles towards the median
#' in logit space). The median value is preserved in the
#' original parameter space.
#' @param knots the number of knots in the transformed distribution, if it is
#'   not already an empirical CDF distribution.
#' @param name a name for the widened distribution
#'
#' @returns an empirical `dist_fn` with the same median and increased SD. This
#'   transformation will change the mean of skewed distributions.
#' @export
#'
#' @examples
#' d1 = as.dist_fns("norm",4,2)
#' w1 = widen(d1, scale=1.5)
#'
#'
#'
widen = function(x, scale, knots = NULL, name = NULL) {
  if (is.dist_fns_list(x)) {
    map_dist_fns(x, function(xi) widen(xi, scale = scale, knots = knots))
  }
  if (!is.dist_fns(x)) {
    stop("`x` must be a distribution as a `dist_fns` S3 object")
  }
  if (scale == 1) {
    return(x)
  }

  if (!inherits(x, "emp_cdf")) {
    if (is.null(knots)) {
      knots = 21
    }

    knotp = seq(0.5 / knots, 1 - 0.5 / knots, length.out = knots)
    knotx = x$q(knotp)

    x2 = empirical_cdf(
      x = knotx,
      p = knotp,
      link = x,
      name = x$name
    )
  } else {
    x2 = x
  }

  qx = x2$p$pfn$qx
  knotp2 = x2$p$pfn$qy

  x_from_qx = x2$p$pfn$x_from_qx
  qx_from_qy = x2$p$pfn$qx_from_qy

  qmedian = qx_from_qy(0.5)

  # this is (expit((logit(x) - logit(qmedian))*scale + logit(qmedian))
  # **Derivation:**
  #
  #   Let `L(x) = logit(x) = log(x / (1 - x))` and `E(x) = expit(x) = 1 / (1 + exp(-x))`.
  #
  # Starting with:
  #   `qx2 = E( (L(qx) - L(qmedian)) * scale + L(qmedian) )`
  # 1.  Substitute `L(x)`:
  #   `qx2 = E( (log(qx / (1 - qx)) - log(qmedian / (1 - qmedian))) * scale + log(qmedian / (1 - qmedian)) )`
  # 2.  Combine the logs in the first term:
  #   `qx2 = E( log( (qx / (1 - qx)) / (qmedian / (1 - qmedian)) ) * scale + log(qmedian / (1 - qmedian)) )`
  #   `qx2 = E( log( (qx * (1 - qmedian)) / ((1 - qx) * qmedian) ) * scale + log(qmedian / (1 - qmedian)) )`
  # 3.  Use `log(a^b) = b * log(a)` for the first term:
  #   `qx2 = E( log( ((qx * (1 - qmedian)) / ((1 - qx) * qmedian))^scale ) + log(qmedian / (1 - qmedian)) )`
  # 4.  Combine the logs:
  #   `qx2 = E( log( ((qx * (1 - qmedian)) / ((1 - qx) * qmedian))^scale * (qmedian / (1 - qmedian)) ) )`
  # 5.  Simplify the expression inside the log:
  #   `qx2 = E( log( (qx^scale * (1 - qmedian)^scale * qmedian) / ((1 - qx)^scale * qmedian^scale * (1 - qmedian)) ) )`
  #   `qx2 = E( log( (qx^scale * (1 - qmedian)^(scale - 1)) / ((1 - qx)^scale * qmedian^(scale - 1)) ) )`
  # 6.  Now apply `E(x) = 1 / (1 + exp(-x))`. The `exp(log(...))` cancels:
  #   `qx2 = 1 / (1 + 1 / ( (qx^scale * (1 - qmedian)^(scale - 1)) / ((1 - qx)^scale * qmedian^(scale - 1)) ) )`
  # 7.  Simplify the complex fraction `1 / (A / B) = B / A`:
  #   `qx2 = 1 / (1 + ((1 - qx)^scale * qmedian^(scale - 1)) / (qx^scale * (1 - qmedian)^(scale - 1)) )`
  # 8.  Get a common denominator for the term in the denominator:
  #   `qx2 = 1 / ( (qx^scale * (1 - qmedian)^(scale - 1)) / (qx^scale * (1 - qmedian)^(scale - 1)) + ((1 - qx)^scale * qmedian^(scale - 1)) / (qx^scale * (1 - qmedian)^(scale - 1)) )`
  # 9.  Combine the fractions in the denominator:
  #   `qx2 = 1 / ( (qx^scale * (1 - qmedian)^(scale - 1) + (1 - qx)^scale * qmedian^(scale - 1)) / (qx^scale * (1 - qmedian)^(scale - 1)) )`
  # 10. Simplify `1 / (C / D) = D / C`:
  #   `qx2 = (qx^scale * (1 - qmedian)^(scale - 1)) / (qx^scale * (1 - qmedian)^(scale - 1) + (1 - qx)^scale * qmedian^(scale - 1))`
  #
  # Thanks AI!
  qx2fn = function(qx, scale) {
    # Simplified version
    numerator = qx^scale * (1 - qmedian)^(scale - 1)
    denominator = numerator + (1 - qx)^scale * qmedian^(scale - 1)
    tmp = numerator / denominator
    # tmp = .expit(((.logit(qx) - .logit(qmedian))*scale)+.logit(qmedian))
    # It does work.
    return(pmin(pmax(tmp, 0), 1))
  }

  qx2 = qx2fn(qx, scale)

  # for a factor > 1 qx2-qx should be negative if < qx<mid x i.e.
  # qx2 is shifted away from median

  knotx2 = x_from_qx(qx2)
  if (is.null(name)) {
    name = sprintf("w(%s,%1.2g)", x$name, scale)
  }

  return(empirical_cdf(
    x = knotx2,
    p = knotp2,
    link = x,
    smooth = TRUE,
    name = name
  ))
}
