# Standalone file: do not edit by hand
# Source: https://github.com/terminological/ggrrr/blob/HEAD/R/standalone-recycle.R
# Generated by: pkgtools::use_standalone("terminological/ggrrr", "recycle")
# ----------------------------------------------------------------------
#
# ---
# repo: terminological/ggrrr
# file: standalone-recycle.R
# last-updated: '2025-07-10'
# license: https://unlicense.org
# imports: rlang
# ---

#' Strictly recycle function parameters
#'
#' `.recycle` is called within a function and ensures the parameters in the
#' calling function are all the same length by repeating them using `rep`. This
#' function alters the environment from which it is called. It is stricter than
#' R recycling in that it will not repeat vectors other than length one to match
#' the longer ones, and it throws more informative errors.
#'
#' NULL values are not recycled, missing values are ignored.
#'
#' @param ... the variables to recycle
#' @param .min the minimum length of the results (defaults to 1)
#' @param .env the environment to recycle within.
#'
#' @return the length of the longest variable
#'
#' @concept parameter_checks
#' @keywords internal
#'
#'
#' @unit
#' testfn = function(a, b, c) {
#'   n = .recycle(a,b,c)
#'   return(list(
#'     a=a, b=b, c=c, n=n
#'   ))
#' }
#'
#' tmp = testfn(a=c(1,2,3), b="needs recycling", c=NULL)
#'
#' testthat::expect_equal(tmp$n, 3)
#' testthat::expect_null(tmp$c)
#' testthat::expect_equal(length(tmp$a), length(tmp$b))
#'
#' # no parameter
#' testthat::expect_error(testfn(a=c(1,2,3), c=NULL))
#'
#' tmp = testfn(a=character(), b=integer(), c=NULL)
#'
#' testthat::expect_equal(tmp$n, 0)
#'
#' # inconsistent to have a zero length and a non zero length
#' testthat::expect_error(testfn(a=c("a","b"), b=integer(), c=NULL))
#'
#' # This is currently unsupported
#' #testfn = function(a, b, c, ...) {
#' # n = .recycle(a,b,c, ...)
#' # return(list(
#' #   a=a, b=b, c=c, n=n, ...
#' # ))
#' #}
#' #
#' #tmp = testfn(a=c(1,2,3), b="needs recycling", c=NULL, d="additional")
#'
.recycle = function(..., .min = 1, .env = rlang::caller_env()) {
  names = names(rlang::ensyms(..., .named = TRUE))
  dots = rlang::enexprs(..., .named = TRUE)
  env = .env

  # TODO: Recycle `...` parameters
  # it would be nice to be able to do this so that
  # we can ensure that parameters passed on are assured to be the correct length
  # however this requires manipulating `...` and inserting it back into the
  # caller environment.
  # for (nm in names) {
  #   # If a parameter is passed to .recycle in `...` it will have a value here
  #   # but this wont actually exist in the target environment. We have to
  #   # create it so we can recycle it. This will force evaluation I expect
  #   if (!is.symbol(dots[[nm]]) && !exists(nm, envir = env, inherits = FALSE)) {
  #     env[[nm]] = dots[[nm]]
  #   }
  # }

  missing = sapply(names, function(x) {
    !(exists(x, envir = env, inherits = FALSE)) || rlang::is_missing(env[[x]])
  })
  # if (any(missing)) warning( paste0(names[missing],collapse=","), " "
  names = names[!missing]
  dots = dots[!missing]
  # browser()

  lengths = sapply(names, function(x) length(env[[x]]))
  nulls = sapply(names, function(x) is.null(env[[x]]))
  lengths[nulls] = NA_integer_

  if (all(is.na(lengths))) {
    return(0)
  } # all parameters are null

  if (all(lengths == 0, na.rm = TRUE)) {
    ml = 0
  } else {
    ml = max(c(lengths, .min), na.rm = TRUE)
  }

  if (!all(lengths %in% c(NA_integer_, 1, ml))) {
    names = names[!lengths %in% c(NA_integer_, 1, ml)]
    stop(
      sprintf(
        "Parameter %s is/are the wrong lengths. They should be length %d%s",
        paste0("`", names, "`", collapse = ","),
        ml,
        if (ml != 1) " (or 1)" else ""
      ),
      call. = FALSE
    )
  }

  if (ml > 1) {
    for (i in seq_along(names)) {
      name = names[[i]]
      x = env[[name]]
      if (length(x) == 1) {
        env[[name]] = rep(x, ml)
      }
    }
  }

  return(ml)
}


#' Strictly recycle the items in a list to the same length
#'
#' This removes NULL entries, and zero length lists
#'
#' @param lst a list input
#'
#' @returns the list with all items recycled to the same length
#' @keywords internal
#'
#' @unit
#' lst = list(a = 1,b=1:3, c= NULL, d=list(), e=character())
#' testthat::expect_equal(
#'   .make_square(lst),
#'   list(a = c(1, 1, 1), b = 1:3)
#' )
.make_square = function(lst) {
  if (is.data.frame(lst)) {
    return(lst)
  }
  if (!is.list(lst)) {
    stop("Input must be a list", .call = FALSE)
  }
  original = lst
  lst = Filter(Negate(is.null), lst)
  lst = Filter(function(x) length(x) > 0, lst)
  lengths = sapply(lst, length)
  if (length(lengths) == 0) {
    return(original)
  }
  max_len = max(lengths)
  if (!all(lengths %in% c(1, max_len))) {
    stop("Inputs must be all either 1 or ", max_len, " long", call. = FALSE)
  }
  return(lapply(
    lst,
    function(x) if (length(x) == 1) rep(x, max_len) else x
  ))
}
