# Templated file: may be overwritten
# Generated by: pkgtools from `template-struct.R`
# ----------------------------------------------------------------------

# ---
# destfile: template-dist_fns-class.R
# last-updated: 2024-03-24
# license: https://unlicense.org
# imports:
#    - knitr
#    - pillar
#    - purrr
#    - rlang
#    - utils
# ---

# Class specific functions ----

#' Create a `dist_fns` S3 object
#'
#' A class wrapping a single (or set) of parametrised distributions and
#' provides access to the quantile, cumulative probability and random functions
#' of that specific distribution. Parametrisation is handled on construction.
#'
#' `dist_fns` and `dist_fns_list` objects support `$` access for fields and `@` access
#' for attributes. `dist_fns_list`s can be made with the `c()` or `rep()` functions,
#' or with the `purrr` style map functions, and they support subsetting.
#' Individual `dist_fns` members of `dist_fns_list`s can be accessed with `[[`.
#'
#' @param x a `dist_fns` S3 object
#' @param ... passed onto methods
#' @name s3_dist_fns
#' @keywords internal
NULL

#' Create a new `dist_fns` S3 object
#' @param name a name for the distribution
#' @param pfn the cumulative probability function
#' @param qfn the quantile function
#' @param rfn the RNG function
#' @param dfn the density function
#' @param ... parameters for the distribution.
#' @param params parameters for the distribution as a named list.
#' @param knots in empirical distributions this holds details on the knot points
#' @returns a new `dist_fns` S3 object or a `dist_fns_list` if parameters are vectorised
#' @concept dist_fns_s3
#' @keywords internal
new_dist_fns = function(
  name = "NULL",
  pfn = pnull,
  qfn = qnull,
  rfn = NULL,
  dfn = NULL,
  ...,
  params = NULL,
  knots = NULL,
  smooth = TRUE
) {
  if (is.null(params)) {
    params = .expand_params(pfn, q = 1, ...)
  } else {
    params = rlang::inject(.expand_params(pfn, q = 1, !!!params))
  }
  params = params[
    !names(params) %in% c("lower.tail", "log.p", "p", "q", "n", "x")
  ]

  if (any(sapply(params, length) > 1)) {
    params = .make_square(params)
    return(pmap_dist_fns(params, function(...) {
      new_dist_fns(
        name = name,
        pfn = pfn,
        qfn = qfn,
        rfn = rfn,
        dfn = dfn,
        ...,
        knots = knots,
        smooth = smooth
      )
    }))
  }
  dots = cl = NULL

  if (is.null(rfn)) {
    rfn = .r_from_q(qfn)
  }
  if (is.null(dfn)) {
    dfn = .d_from_p(pfn, knots)
  }

  return(
    structure(
      list(
        name = if (length(params) > 0) {
          gsub("^[^(]+", name, deparse(sapply(params, signif, 3)))
        } else {
          name
        },
        p = carrier::crate(
          function(q, lower.tail = TRUE, log.p = FALSE) {
            # TODO: Support for lower.tail and log.p parameters
            # Issue URL: https://github.com/ai4ci/tidyabc/issues/11
            # Delegate to the functions if in formals of pfn?
            tmp = pfn(q = q, !!!params)
            if (!lower.tail) {
              tmp = 1 - tmp
            }
            if (log.p) {
              tmp = log(tmp)
            }
            return(tmp)
          },
          pfn = pfn
        ),
        q = carrier::crate(
          function(p, lower.tail = TRUE, log.p = FALSE) {
            if (log.p) {
              p = exp(p)
            }
            if (!lower.tail) {
              p = 1 - p
            }
            tmp = qfn(p = p, !!!params)
            return(tmp)
          },
          qfn = qfn
        ),
        r = carrier::crate(
          function(n) {
            rfn(n = n, !!!params)
          },
          rfn = rfn
        ),
        d = carrier::crate(
          function(x, log = FALSE) {
            tmp = dfn(x = x, !!!params)
            if (log) {
              tmp = log(tmp)
            }
            return(tmp)
          },
          dfn = dfn
        )
      ),
      dist = name,
      params = if (length(params) == 0) list() else params,
      discrete = suppressWarnings(is.integer(rfn(1, ...))), # detect discrete distributions
      smooth = smooth,
      knots = knots,
      class = c("dist_fns")
    )
  )
}

#' Create a new `dist_fns` S3 object
#' @param name a name for the distribution
#' @param pcall a call of the cumulative probability function
#' @param qcall a call of the quantile function
#' @param rcall a call of the RNG function
#' @param dcall a call of the density function
#' @param ... parameters for the distribution.
#' @param params parameters for the distribution as a named list.
#' @param knots in empirical distributions this holds details on the knot points
#' @returns a new `dist_fns` S3 object or a `dist_fns_list` if parameters are vectorised
#' @concept dist_fns_s3
#' @keywords internal
#' @unit
#' tmp = new_dist_calls(name="norm",
#'   pcall=.qual("pnorm"),
#'   qcall=.qual("qnorm"),
#'   rcall=.qual("rnorm"),
#'   dcall=.qual("dnorm")
#' )
#' testthat::expect_equal(tmp$p(-2:2), c(
#'   0.0227501319481792,
#'   0.158655253931457,
#'   0.5,
#'   0.841344746068543,
#'   0.977249868051821
#' ))
new_dist_calls = function(
  name = "NULL",
  pcall,
  qcall,
  rcall,
  dcall,
  ...,
  params = NULL,
  knots = NULL,
  smooth = TRUE
) {
  pfn = eval(pcall)
  if (is.null(params)) {
    params = .expand_params(pfn, q = 1, ...)
  } else {
    params = rlang::inject(.expand_params(pfn, q = 1, !!!params))
  }
  params = params[
    !names(params) %in% c("lower.tail", "log.p", "p", "q", "n", "x")
  ]

  if (any(sapply(params, length) > 1)) {
    params = .make_square(params)
    return(pmap_dist_fns(params, function(...) {
      new_dist_calls(
        name = name,
        pcall = pcall,
        qcall = qcall,
        rcall = rcall,
        dcall = dcall,
        ...,
        knots = knots
      )
    }))
  }

  pcall = as.call(c(
    pcall,
    expression(q = q, lower.tail = lower.tail, log.p = log.p),
    params
  ))
  qcall = as.call(c(
    qcall,
    expression(p = p, lower.tail = lower.tail, log.p = log.p),
    params
  ))
  rcall = as.call(c(rcall, expression(n = n), params))
  dcall = as.call(c(dcall, expression(x = x, log = log), params))
  rfn = function(n) eval(rcall)
  return(
    structure(
      list(
        name = if (length(params) > 0) {
          gsub("^[^(]+", name, deparse(sapply(params, signif, 3)))
        } else {
          name
        },
        p = carrier::crate(
          function(q, lower.tail = TRUE, log.p = FALSE) {
            !!pcall
          }
        ),
        q = carrier::crate(
          function(p, lower.tail = TRUE, log.p = FALSE) {
            !!qcall
          }
        ),
        r = carrier::crate(
          function(n) {
            !!rcall
          }
        ),
        d = carrier::crate(
          function(x, log = FALSE) {
            !!dcall
          }
        )
      ),
      dist = name,
      params = if (length(params) == 0) list() else params,
      discrete = suppressWarnings(is.integer(rfn(1))), # detect discrete distributions
      knots = knots,
      smooth = smooth,
      class = c("dist_fns")
    )
  )
}

# .expand_params(rgamma, 1000, shape=1)
.expand_params = function(fn, ...) {
  # Find the args that are going to match the calls
  dots = rlang::list2(...)
  cl = list(fn, ...)
  cl = cl[names(cl) %in% c("", names(formals(fn)))]

  # evaluate dots in context of a call to fn matching unnamed
  dots = tryCatch(
    {
      # construct a call to fn with the `...` parameters
      tmp = match.call(fn, as.call(cl), expand.dots = TRUE)
      as.list(tmp) # [-(1:2)]
    },
    error = function(e) {
      list()
    }
  )
  # fill in formals from fn
  dots = utils::modifyList(formals(fn), dots)
  dots = Filter(Negate(is.call), dots)
  # filter other
  dots
}

.r_from_q = function(qfn) {
  return(carrier::crate(
    function(n) qfn(stats::runif(n)),
    qfn = qfn
  ))
}

# x=1:10
# xk = c(2,5)
.d_from_p = function(pfn, knots = NULL) {
  e = sqrt(.Machine$double.eps)
  if (!is.null(knots)) {
    return(carrier::crate(
      function(x) {
        spans_knot = apply(
          sapply(knots$x, function(.xk) x > .xk - e & x < .xk + e),
          MARGIN = 1,
          FUN = any
        )
        x1 = x + e
        x0 = x - e * spans_knot
        dx = e + e * spans_knot
        d = (pfn(x1) - pfn(x0)) / dx
        return(d)
      },
      knots = knots,
      e = e,
      pfn = pfn
    ))
  } else {
    return(carrier::crate(
      function(x) {
        return((pfn(x + e) - pfn(x - e)) / (2 * e))
      },
      pfn = pfn,
      e = e
    ))
  }
}

#' Format a `dist_fns` S3 object
#'
#' @inheritParams s3_dist_fns
#' @param digits the number of significant digits
#' @export
#' @returns a character value
#' @concept dist_fns_s3
format.dist_fns = function(x, ..., digits = 3) {
  return(sprintf(
    "%s; Median (IQR) %s [%s \u2014 %s]",
    x$name,
    format(x$q(0.5), ..., digits = digits),
    format(x$q(0.25), ..., digits = digits),
    format(x$q(0.75), ..., digits = digits)
  ))
}

#' Plot a `dist_fns` S3 object
#'
#' @inheritParams s3_dist_fns
#' @export
#' @inheritDotParams plot.dist_fns_list
#' @returns a ggplot
#' @concept dist_fns_s3
plot.dist_fns = function(x, ...) {
  plot(c(x), ...)
}

#' Plot a `dist_fns_list` S3 object
#'
#' Plot a smoothed version of the PDFs of a set of `dist_fns`. These are `ggplots`
#' that can be facetted by `names`, `id` or `group`
#'
#' @export
#' @param x a `dist_fns_list`
#' @param ... passed to `ggplot2::geom_step`,`ggplot2::geom_rect` or `ggplot2::geom_area`,
#' @param mapping override default aesthetics with `name`, `id` or `group`
#' @param steps resolution of the plot
#' @param tail the minimum tail probability to plot
#' @param plot_quantiles by default the quantiles of the distribution are
#'   plotted over the density sometimes this makes it hard to read
#' @param smooth by default some additional smoothing is used to cover up small
#'   discontinuities in the PDF.
#' @returns a ggplot
#' @concept dist_fns_s3
plot.dist_fns_list = function(
  x,
  ...,
  mapping = .gg_check_for_aes(...),
  steps = 200,
  tail = 0.001,
  plot_quantiles = TRUE,
  smooth = TRUE
) {
  # TODO: CDF plot for `dist_fns`.
  # Issue URL: https://github.com/ai4ci/tidyabc/issues/10
  # TODO: Adopt ggplot autoplot and autolayer conventions for `dist_fns`
  # TODO: Plot for empirical density function
  # Issue URL: https://github.com/ai4ci/tidyabc/issues/8
  # e.g. plot e$p$pfn$qx_from_qy as a function for CDF fit

  ys = seq(tail, 1 - tail, length.out = steps + 1)
  df = dplyr::tibble(
    name = x$name,
    discrete = x@discrete,
    data = lapply(x, function(xx) {
      xs = unique(xx$q(ys))
      dys = xx$d(xs)
      sdys = if (!xx@discrete && xx@smooth && smooth) {
        signal::sgolayfilt(dys, n = steps %/% 16 * 2 + 1)
      } else {
        dys
      }
      return(
        dplyr::tibble(
          xmin = xs,
          y = dys,
          sy = sdys,
          xmax = c(xs[-1], max(xs) + 1)
        )
      )
    })
  )

  df = df %>%
    dplyr::mutate(
      quants = purrr::map2(x, data, function(xx, data_i) {
        xs = xx$q(c(0.025, 0.5, 0.975))
        return(
          dplyr::tibble(
            q = c(0.025, 0.5, 0.975),
            xs = xs,
            ys = tryCatch(
              stats::approx(x = data_i$xmin, y = data_i$sy, xout = xs)$y,
              error = function(e) xx$d(xs)
            )
          )
        )
      })
    )

  df = df %>%
    dplyr::group_by(name) %>%
    dplyr::mutate(
      id = sprintf("%s [%d]", name, dplyr::row_number()),
      group = as.factor(dplyr::row_number())
    ) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(dplyr::desc(group))

  plot = ggplot2::ggplot() +
    ggplot2::xlab("x") +
    ggplot2::ylab("density")

  if (any(x@discrete)) {
    ddf = df %>% dplyr::filter(discrete) %>% tidyr::unnest(data)
    plot = plot +
      .gg_layer(
        ggplot2::GeomRect,
        data = ddf,
        mapping = .gg_merge_aes(
          xmin = xmin,
          xmax = xmax,
          ymax = y,
          fill = name,
          group = id,
          mapping
        ),
        ymin = 0,
        alpha = 0.2,
        ...,
        .default = list(colour = NA, fill = "grey")
      ) +
      .gg_layer(
        ggplot2::GeomStep,
        data = ddf,
        mapping = ggplot2::aes(x = xmin, y = y, !!!mapping),
        ...,
        direction = "hv",
        .default = list(colour = "black")
      )
  }
  if (any(!x@discrete)) {
    cdf = df %>%
      dplyr::filter(!discrete) %>%
      tidyr::unnest(data) %>%
      dplyr::group_by(name) %>%
      dplyr::filter(
        sy < stats::quantile(sy, 0.99, na.rm = TRUE) * 1 / 0.95,
        sy > 0
      )

    plot = plot +
      .gg_layer(
        ggplot2::GeomArea,
        data = cdf,
        mapping = .gg_merge_aes(
          x = xmin,
          y = sy,
          fill = name,
          group = id,
          mapping
        ),
        ...,
        alpha = 0.2
      )
  }

  if (isTRUE(plot_quantiles)) {
    qf = df %>% tidyr::unnest(quants)
    plot = plot +
      .gg_layer(
        ggplot2::GeomSegment,
        data = qf,
        mapping = .gg_merge_aes(
          x = xs,
          xend = xs,
          yend = ys,
          colour = name,
          group = id,
          mapping
        ),
        y = 0,
        ...,
        .default = list(colour = "black")
      )
    # +
    # .gg_layer(
    #   ggplot2::GeomPoint,
    #   data = qf,
    #   mapping = .gg_merge_aes(
    #     x = xs,
    #     y = ys,
    #     colour = name,
    #     group = id,
    #     mapping
    #   ),
    #   ...,
    #   .default = list(colour = "black")
    # )
  }

  plot
}

#' @export
#' @describeIn as.dist_fns Construct a distribution by name
#' @concept dist_fns_s3
#' @unit
#' pois = as.dist_fns("pois",lambda = 8)
#' n = as.dist_fns("norm",mean=4)
as.dist_fns.character = function(x, ...) {
  if (length(x) > 1) {
    stop("This does not accept vector inputs for `x`")
  }
  distr = x
  fn_names = paste0(c("p", "q", "r", "d"), distr)

  pkg_list = lapply(fn_names, utils::find, mode = "function") %>%
    lapply(setdiff, ".GlobalEnv")
  if (all(sapply(pkg_list, length) > 0)) {
    rawcalls = lapply(seq_along(fn_names), function(i) {
      pkg = gsub("package:", "", pkg_list[[i]])
      .qual(fn_names[[i]], pkg)
    })

    return(
      new_dist_calls(
        distr,
        pcall = rawcalls[[1]],
        qcall = rawcalls[[2]],
        rcall = rawcalls[[3]],
        dcall = rawcalls[[4]],
        ...
      )
    )
  } else {
    #Non package functions?
    if (
      !all(sapply(
        fn_names,
        exists,
        mode = "function",
        envir = rlang::caller_env()
      ))
    ) {
      stop(
        "The functions: ",
        paste0(fn_names, collapse = ", "),
        " must be defined."
      )
    }

    rawfns = lapply(
      fn_names,
      get,
      mode = "function",
      envir = rlang::caller_env()
    )

    return(
      new_dist_fns(
        distr,
        pfn = rawfns[[1]],
        qfn = rawfns[[2]],
        rfn = rawfns[[3]],
        dfn = rawfns[[4]],
        ...
      )
    )
  }
}

#' @export
#' @describeIn as.dist_fns From a statistical function
#' @concept dist_fns_s3
as.dist_fns.function = function(x, ...) {
  if (length(x) > 1) {
    stop("This does not accept vector inputs for `x`")
  }
  distr = deparse(substitute(x)) #rlang::enexpr(x)
  name = gsub("^([^:]+::)?[dpqr]", "", distr, perl = TRUE)
  fn_names = paste0(c("p", "q", "r", "d"), name)

  pkg = rlang::fn_env(x)
  pkgname = rlang::env_name(pkg)

  if (!all(sapply(fn_names, exists, mode = "function", envir = pkg))) {
    stop(
      "The functions: ",
      paste0(fn_names, collapse = ", "),
      " must be defined in ",
      pkgname
    )
  }

  if (grepl("namespace:", pkgname, fixed = TRUE)) {
    rawcalls = lapply(fn_names, .qual, pkg)
    return(
      new_dist_calls(
        name,
        pcall = rawcalls[[1]],
        qcall = rawcalls[[2]],
        rcall = rawcalls[[3]],
        dcall = rawcalls[[4]],
        ...
      )
    )
  } else {
    # function must exist somewhere but we will need to get it
    # and crate it:

    rawfns = lapply(fn_names, get, mode = "function", envir = pkg)
    return(
      new_dist_fns(
        distr,
        pfn = rawfns[[1]],
        qfn = rawfns[[2]],
        rfn = rawfns[[3]],
        dfn = rawfns[[4]],
        ...
      )
    )
  }
}

#' @export
#' @describeIn as.dist_fns From a `fitdistrplus::fitdist` output
#' @concept dist_fns_s3
as.dist_fns.fitdist = function(x, ...) {
  as.dist_fns.character(x$distname, params = as.list(x$estimate))
}

#' @param x a `dist_fns` S3 class
#' @returns a numeric or other order-able item
#' @noRd
.sort_by_dist_fns = function(x) {
  stop("`dist_fns` is not sortable.")
}


# Boilerplate generated functions ----

# S3 classes can be used in a  number of styles as described in the `vctrs`
# package. This template provides some basic infrastructure for creating an S3
# `scalar` class style. This is centred around a list of unequal length data, or
# functions, like the output of base `stats::lm`. To make these work in data
# frames we need an ancillary list class that allows the object to be
# incorporated into data frames or operated on by `purrr`. These objects are not
# obviously useful in operations like addition etc., and are just dumb
# structured data holders that behave approximately predictably when combined
# into lists. The list classes are sortable and subset-able.

# S3 dist_fns class ----

#' Check if this is a `dist_fns` S3 object
#' @export
#' @param x anything
#' @returns TRUE or FALSE
#' @concept dist_fns_s3
is.dist_fns = function(x) {
  return(inherits(x, "dist_fns"))
}

#'  Check if this is a `dist_fns_list` S3 object
#' @param x anything
#' @returns TRUE or FALSE
#' @export
#' @concept dist_fns_s3
is.dist_fns_list = function(x) {
  inherits(x, "dist_fns_list")
}

#' @inherit s3_dist_fns
#' @export
#' @returns a `dist_fns` S3 object
#' @concept dist_fns_s3
as.dist_fns = function(x, ...) {
  if (missing(x)) {
    return(new_dist_fns())
  }
  if (is.dist_fns(x)) {
    return(x)
  }
  UseMethod("as.dist_fns", x)
}

#' Concatenate a `dist_fns` S3 object or `dist_fns_list`s
#' @param ... some of `dist_fns`, `dist_fns_list`s or lists of `dist_fns`
#' @returns a `dist_fns_list`
#' @concept dist_fns_s3
#' @export
c.dist_fns = function(...) {
  dots = rlang::list2(...)
  if (length(dots) == 0) {
    return(as.dist_fns_list(NULL))
  }
  dots[[1]] = as.dist_fns_list(dots[[1]])
  return(do.call(c.dist_fns_list, dots))
}

#' Apply a function to each element of a vector returning a `dist_fns_list`
#'
#' Analogous to `purrr::map_dbl()`
#'
#' @inheritParams purrr::map
#' @param .f a function to apply that returns a `dist_fns` S3 object (usually an
#'   ``as.dist_fns()`` call)
#' @seealso [purrr::map()]
#'
#' @returns a `dist_fns_list`
#' @export
#' @concept dist_fns_s3
map_dist_fns = function(.x, .f, ..., .progress = FALSE) {
  # This will flatten any nested dist_fns_lists. This is good as .f may return a
  # single dist_fns or more likely a 1 element dist_fns_list.
  return(purrr::map(.x, .f, ..., .progress = .progress) %>% as.dist_fns_list())
}

#' Map over two inputs returning a `dist_fns_list`
#'
#' Analogous to `purrr::map2_dbl()`
#'
#' @inheritParams purrr::map2
#' @param .f a function to apply to each `.x`, `.y` pair that returns a `dist_fns`
#'   S3 object (usually an ``as.dist_fns()`` call)
#' @seealso [purrr::map2()]
#'
#' @returns a `dist_fns_list`
#' @export
#' @concept dist_fns_s3
map2_dist_fns = function(.x, .y, .f, ..., .progress = FALSE) {
  return(
    purrr::map2(.x, .y, .f, ..., .progress = .progress) %>% as.dist_fns_list()
  )
}

#' Map over multiple inputs returning a `dist_fns_list`
#'
#' Analogous to `purrr::pmap_dbl()`
#'
#' @inheritParams purrr::pmap
#' @param .f a function to apply to each `.l` item (usually an ``as.dist_fns()`` call)
#' @seealso [purrr::map()]
#' @returns a `dist_fns_list`
#' @export
#' @concept dist_fns_s3
pmap_dist_fns = function(.l, .f, ..., .progress = FALSE) {
  return(
    purrr::pmap(
      .l,
      .f,
      ...,
      .progress = .progress
    ) %>%
      as.dist_fns_list()
  )
}

#' Create an empty `dist_fns_list`
#' @inherit s3_dist_fns_common
#' @export
#' @returns an empty `dist_fns_list`
#' @concept dist_fns_s3
dist_fns = function() {
  return(as.dist_fns_list(NULL))
}

## Utility functions ----

# removes this class from the object - internal use
.unclass_dist_fns = function(x) {
  class(x) <- setdiff(class(x), "dist_fns")
  return(x)
}

# x is a list but not a dist_fns. This means it is a plain list
# or a dist_fns_list
.is_list_excl_dist_fns = function(x) {
  if (!is.list(x)) {
    return(FALSE)
  }
  if (is.dist_fns(x)) {
    return(FALSE)
  }
  return(TRUE)
}

## Hidden exported functions ----

#' `dist_fns` S3 Class operations
#'
#' Boilerplate S3 class operation
#'
#' @param x a `dist_fns` S3 object
#' @param ... passed onto methods
#' @name s3_dist_fns_common
#' @keywords internal
NULL


#' Default method throws error
#' @export
#' @inherit s3_dist_fns_common
#' @returns nothing
#' @concept dist_fns_s3
#' @keywords internal
as.dist_fns.default = function(x, ...) {
  if (is.dist_fns(x)) {
    return(x)
  }
  stop("Don't know how to convert a `", class(x)[[1]], "` to a `dist_fns`.")
}

#' Cast a `dist_fns` S3 object to a character vector
#' @inherit s3_dist_fns_common
#' @export
#' @returns a character vector
#' @concept dist_fns_s3
#' @keywords internal
as.character.dist_fns = function(x, ...) {
  return(format(x, ...))
}

#' Print a `dist_fns` S3 object
#' @inherit s3_dist_fns_common
#' @export
#' @returns nothing
#' @concept dist_fns_s3
#' @keywords internal
print.dist_fns = function(x, ...) {
  cat(suppressWarnings(format(x, ...)))
  invisible(NULL)
}

#' Print a `dist_fns` S3 object in an Rd document
#' @exportS3Method knitr::knit_print dist_fns
#' @inherit s3_dist_fns_common
#' @returns an `as-is` knitr chunk
#' @concept dist_fns_s3
#' @keywords internal
knit_print.dist_fns = function(x, ...) {
  structure(format(x), class = "knit_asis")
}

#' `dist_fns` S3 objects length is always 1
#' @export
#' @inherit s3_dist_fns_common
#' @returns 1 always
#' @concept dist_fns_s3
#' @keywords internal
length.dist_fns = function(x, ...) {
  return(1)
}

#' Pillar type name
#' @exportS3Method pillar::type_sum dist_fns
#' @inherit s3_dist_fns_common
#' @returns a string
#' @concept dist_fns_s3
#' @keywords internal
type_sum.dist_fns = function(x, ...) {
  "distfn"
}


#' Extract named attribute from a `dist_fns`
#' @inherit s3_dist_fns_common
#' @param y item to retrieve
#' @returns an attribute value for `x`
#' @export
#' @concept dist_fns_s3
#' @keywords internal
#' @name at.dist_fns
`@.dist_fns` = function(x, y) {
  if (is.character(y)) {
    ylab = y
  } else {
    ylab = deparse(substitute(y))
  }
  return(attr(x, ylab))
}

#' Support for auto suggests on `dist_fns_list`s
#' @inherit s3_dist_fns_common
#' @param pattern a regular expression
#' @returns the names of the attributes
#' @exportS3Method utils::.AtNames dist_fns
#' @concept dist_fns_s3
#' @keywords internal
.AtNames.dist_fns = function(x, pattern) {
  return(utils::.DollarNames(attributes(x), pattern))
}


#' Repeat an `dist_fns` S3 object
#' @inherit s3_dist_fns_common
#' @inheritDotParams base::rep -x
#' @returns a `dist_fns_list`
#' @export
#' @concept dist_fns_s3
#' @keywords internal
rep.dist_fns = function(x, ...) {
  rep(as.dist_fns_list(x), ...)
}

#' Convert a `dist_fns` S3 object into a plain list
#' @inherit s3_dist_fns_common
#' @export
#' @returns the internal structure of the object as a plain list
#' @concept dist_fns_s3
#' @keywords internal
as.list.dist_fns = function(x, ...) {
  .unclass_dist_fns(x)
}

# S3 dist_fns_list class ----

## Hidden exported functions ----

#' Manipulate `dist_fns` S3 object lists
#'
#' These boilerplate functions allow generic list behaviour from `dist_fns_list`
#' classes allowing `dist_fns` S3 objects to be used in lists or dataframes.
#'
#' @param x a `dist_fns_list` S3 object
#' @param ... passed onto methods
#'
#' @name s3_dist_fns_list
#' @keywords internal
NULL

#' Un format the `dist_fns_list`
#' @inherit s3_dist_fns_list
#' @export
#' @concept dist_fns_s3
#' @keywords internal
#' a plain list of `dist_fns` S3 objects
as.list.dist_fns_list = function(x, ...) {
  unclass(x)
}

#' Length of a `dist_fns_list`
#' @inherit s3_dist_fns_list
#' @export
#' @returns the length
#' @concept dist_fns_s3
#' @keywords internal
length.dist_fns_list = function(x, ...) {
  return(length(unclass(x)))
}


#' Cast to a list of `dist_fns` S3 objects
#'
#' This function wraps `dist_fns` and unwraps plain lists such that
#' the result is a flat `dist_fns_list` containing `dist_fns` objects only
#'
#' @inherit s3_dist_fns_list
#' @return a `dist_fns_list` S3 object
#' @export
#' @concept dist_fns_s3
#' @keywords internal
as.dist_fns_list = function(x) {
  if (length(unlist(x)) == 0) {
    # .class may be asserted when creating zero size / NULL `dist_fns`s
    return(structure(list(), class = c("dist_fns_list", "list")))
  }
  if (is.dist_fns(x)) {
    return(structure(list(x), class = c("dist_fns_list", "list")))
  }
  if (is.list(x)) {
    # x is a list or dist_fns_list (but cannot be a single dist_fns at this point)
    while (any(sapply(x, .is_list_excl_dist_fns))) {
      # if there are any nested dist_fns_lists or plain lists we will collapse
      # them . A dist_fns_list must be a list of dist_fnss without hierarchy.
      # We also have to make sure that plain dist_fnss are wrapped
      x = lapply(x, as.dist_fns_list)
      x = unlist(x, recursive = FALSE)
    }
    return(structure(x, class = c("dist_fns_list", "list")))
  }

  stop(
    "Not convertible to a `dist_fns_list` x is not `dist_fns_list`, a `dist_fns` or a uniform list of `dist_fns`s",
    call. = FALSE
  )
}

#' Format a `dist_fns_list`
#' @inherit s3_dist_fns_list
#' @export
#' @returns a character vector for the list
#' @concept dist_fns_s3
#' @keywords internal
format.dist_fns_list = function(x, ...) {
  unlist(lapply(x, format))
}

#' Print a `dist_fns_list`
#' @inherit s3_dist_fns_list
#' @export
#' @returns nothing
#' @concept dist_fns_s3
#' @keywords internal
print.dist_fns_list = function(x, ...) {
  cat(sprintf("dist_fns(%s)\n", length(x)))
  cat(suppressWarnings(format.dist_fns_list(x, ...)), "\n")
  invisible(NULL)
}

#' Convert a `dist_fns_list` to character
#' @inherit s3_dist_fns_list
#' @export
#' @returns a character vector
#' @concept dist_fns_s3
#' @keywords internal
as.character.dist_fns_list = function(x, ...) {
  format.dist_fns_list(x, ...)
}

#' Pillar type name
#' @inherit s3_dist_fns_list
#' @exportS3Method pillar::type_sum dist_fns_list
#' @concept dist_fns_s3
#' @returns a name
#' @keywords internal
type_sum.dist_fns_list = function(x, ...) {
  I(sprintf("<%s[]>", "distfn"))
}

#' Pillar shaft function
#' @inherit s3_dist_fns_list
#' @returns a pillar shaft
#' @exportS3Method pillar::pillar_shaft
#' @concept dist_fns_s3
#' @keywords internal
pillar_shaft.dist_fns_list <- function(x, ...) {
  out <- format.dist_fns_list(x, ...)
  pillar::new_pillar_shaft_simple(out, align = "right")
}

#' Concatenate or construct a `dist_fns_list`
#'
#' @param ... some of `dist_fns_list` and `dist_fns` or list of `dist_fns`s
#' @returns a flattened `dist_fns_list` S3 object
#' @export
#' @concept dist_fns_s3
#' @keywords internal
c.dist_fns_list = function(...) {
  dots = rlang::list2(...)
  if (is.dist_fns_list(dots)) {
    return(dots)
  }
  if (length(dots) == 1) {
    return(as.dist_fns_list(dots))
  }
  # remove empty items
  dots = dots[sapply(dots, length) > 0]
  # make sure all list entries are a dist_fns list (dots is list of dist_fns_list)
  tmp = lapply(dots, as.dist_fns_list)
  # convert to plain list of lists
  tmp = lapply(tmp, as.list.dist_fns_list)
  # collapse one level
  tmp = unlist(tmp, recursive = FALSE)
  # convert to dist_fns_list. this should throw an error if types are mixed.
  return(as.dist_fns_list(tmp))
}

#' Repeat a `dist_fns_list`
#' @inherit s3_dist_fns_list
#' @inheritDotParams base::rep -x
#' @returns a `dist_fns_list` S3 object
#' @concept dist_fns_s3
#' @export
#' @keywords internal
rep.dist_fns_list = function(x, ...) {
  tmp = NextMethod()
  return(as.dist_fns_list(tmp))
}


#' Sort a `dist_fns_list`
#' @inherit s3_dist_fns_list
#' @param decreasing reverse the sort order
#' @returns an ordered `dist_fns_list` S3 object
#' @export
#' @concept dist_fns_s3
#' @keywords internal
sort.dist_fns_list = function(x, decreasing = FALSE, ...) {
  indx = order(unlist(sapply(x, .sort_by_dist_fns)))
  if (decreasing) {
    indx = rev(indx)
  }
  return(x[indx])
}

### dist_fns_list Subsetting functions ----

#' Extract named item(s) from a `dist_fns_list`
#' @inherit s3_dist_fns_list
#' @param y item to retrieve
#' @returns a list or vector of the named items
#' @export
#' @concept dist_fns_s3
#' @keywords internal
`$.dist_fns_list` = function(x, y) {
  if (is.character(y)) {
    ylab = y
  } else {
    ylab = deparse(substitute(y))
  }
  if (length(x) == 1) {
    return(x[[1]][[ylab]])
  }
  return(sapply(seq_along(x), function(i) x[[i]][[ylab]], USE.NAMES = FALSE))
}

#' Support for auto suggests on `dist_fns_list`s
#' @inherit s3_dist_fns_list
#' @returns the names of the children
#' @exportS3Method utils::.DollarNames dist_fns_list
#' @concept dist_fns_s3
#' @keywords internal
.DollarNames.dist_fns_list = function(x, pattern) {
  if (length(x) == 0) {
    return(character())
  }
  return(utils::.DollarNames(x[[1]], pattern))
}

#' Extract named item(s) from a `dist_fns_list`
#' @inherit s3_dist_fns_list
#' @param y attribute to retrieve
#' @returns a vector or list of the underlying `dist_fns` attribute values
#' @export
#' @concept dist_fns_s3
#' @keywords internal
#' @name at.dist_fns_list
`@.dist_fns_list` = function(x, y) {
  if (is.character(y)) {
    ylab = y
  } else {
    ylab = deparse(substitute(y))
  }
  if (length(x) == 1) {
    return(attr(x[[1]], ylab))
  }
  return(unname(sapply(
    seq_along(x),
    function(i) attr(x[[i]], ylab),
    USE.NAMES = FALSE
  )))
}

#' Support for auto suggests on `dist_fns_list`s
#' @inherit s3_dist_fns_list
#' @returns the names of the attributes
#' @exportS3Method utils::.AtNames dist_fns_list
#' @concept dist_fns_s3
#' @keywords internal
.AtNames.dist_fns_list = function(x, pattern) {
  if (length(x) == 0) {
    return(character())
  }
  return(utils::.DollarNames(attributes(x[[1]]), pattern))
}

#' Subset a `dist_fns_list`
#' @inherit s3_dist_fns_list
#' @returns a `dist_fns_list` S3 object
#' @export
#' @concept dist_fns_s3
#' @keywords internal
`[.dist_fns_list` = function(x, ...) {
  y = `[`(unclass(x), ...)
  return(as.dist_fns_list(y))
}

#' Assign a subset to a `dist_fns_list`
#' @inherit s3_dist_fns_list
#' @param value the value as `dist_fns_list` or `dist_fns` S3 objects
#' @returns the updated `dist_fns_list` S3 object
#' @export
#' @concept dist_fns_s3
#' @keywords internal
`[<-.dist_fns_list` = function(x, ..., value) {
  if (!is.dist_fns_list(value) && !is.dist_fns(value)) {
    stop(
      "cannot add a `",
      class(value)[[1]],
      "` to a `dist_fns_list`"
    )
  }
  y = `[<-`(unclass(x), ..., value)
  return(as.dist_fns_list(y))
}

#' get a value from a `dist_fns_list`
#' @inherit s3_dist_fns_list
#' @returns a `dist_fns` S3 object
#' @export
#' @concept dist_fns_s3
#' @keywords internal
`[[.dist_fns_list` = function(x, ...) {
  y = `[[`(unclass(x), ...)
  return(y)
}

#' set a single value in a `dist_fns_list`
#' @inherit s3_dist_fns_list
#' @param value the value
#' @returns the updated `dist_fns_list` S3 object
#' @export
#' @concept dist_fns_s3
#' @keywords internal
`[[<-.dist_fns_list` = function(x, ..., value) {
  if (is.dist_fns_list(value) && length(value) == 1) {
    value = value[[1]]
  }
  if (!is.dist_fns(value)) {
    stop(
      "cannot add a `",
      class(value)[[1]],
      "` to a `dist_fns_list`"
    )
  }
  y = `[[<-`(unclass(x), ..., value)
  return(as.dist_fns_list(y))
}
