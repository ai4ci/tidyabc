# Templated file: may be overwritten
# Generated by: pkgtools from `template-struct.R`
# ----------------------------------------------------------------------

# ---
# destfile: template-link_fns-class.R
# last-updated: 2024-03-24
# license: https://unlicense.org
# imports:
#    - knitr
#    - pillar
#    - purrr
#    - rlang
#    - utils
# ---

#' Create a `link_fns` S3 object
#'
#' The link function class allows forwards and backwards transformation.
#' Link functions can be defined by name or using a statistical distribution
#' in which case the forward link is a logit of the cumulative probability
#' and the reverse is the quantile of the expit.
#'
#' `link_fns` and `link_fns_list` objects support `$` access for fields and `@` access
#' for attributes. `link_fns_list`s can be made with the `c()` or `rep()` functions,
#' or with the `purrr` style map functions, and they support subsetting.
#' Individual `link_fns` members of `link_fns_list`s can be accessed with `[[`.
#'
#' @param x a `link_fns` S3 object
#' @param ... passed onto methods
#' @name s3_link_fns
#' @keywords internal
NULL

#' Create a new `link_fns` S3 object
#'
#' Default is an identity link
#'
#' @param trans the forward transforming function
#' @param inv the reverse inverting function
#' @param support the support or support of the link
#' @returns a new `link_fns` S3 object
#' @concept link_fns_s3
#' @keywords internal
new_link_fns = function(
  trans = ~.x,
  inv = ~.x,
  support = c(-Inf, Inf),
  ddxtrans = NULL,
  ddxinv = NULL,
  name = NULL
) {
  if (rlang::is_formula(trans)) {
    if (is.null(ddxtrans)) {
      cl = try(stats::D(rlang::f_rhs(trans), ".x"), silent = TRUE)
      if (is.call(cl)) ddxtrans = as.function(c(alist(.x = ), cl))
    }
  }

  if (rlang::is_formula(inv)) {
    if (is.null(ddxinv)) {
      cl = try(stats::D(rlang::f_rhs(inv), ".x"), silent = TRUE)
      if (is.call(cl)) ddxinv = as.function(c(alist(.x = ), cl))
    }
  }

  trans = rlang::as_function(trans)
  inv = rlang::as_function(inv)

  if (is.null(name)) {
    name = paste0(format(body(trans)), collapse = ";")
  }

  if (is.null(ddxtrans)) {
    ddxtrans = .numderivfn(trans)
  }
  if (is.null(ddxinv)) {
    ddxinv = .numderivfn(inv)
  }

  trans = rlang::as_function(trans)
  inv = rlang::as_function(inv)

  range = trans(support)
  stopifnot(length(support) == 2, length(range) == 2)

  return(structure(
    list(
      name = name,
      trans = trans,
      inv = inv,
      ddxtrans = ddxtrans,
      ddxinv = ddxinv,
      support = support,
      range = range
    ),
    class = c("link_fns")
  ))
}

.numderivfn = function(fn) {
  return(function(x) {
    eps = sqrt(.Machine$double.eps)
    return((fn(x + eps) - fn(x - eps)) / (2 * eps))
  })
}

#' Format a `link_fns` S3 object
#' @export
#' @inheritParams s3_link_fns
#' @returns a character value
#' @concept link_fns_s3
format.link_fns = function(x, ...) {
  return(sprintf("%s link [%1.3g, %1.3g]", x$name, x$support[1], x$support[2]))
}

#' @export
#' @describeIn as.link_fns Link function from name
#' @concept link_fns_s3
#' @param x one of "ident", "log", "logit", "probit", "cloglog", "neginv", "inv2"
#' @param ... ignored
#' @unit
#' links = c("ident", "log", "logit", "probit", "cloglog", "neginv", "inv2")
#' test = seq(0.1,0.9,0.1) # within support of all links
#' for (l in links) {
#'   lfn = as.link_fns(l)
#'   t = lfn$trans(test)
#'   i = lfn$inv(t)
#'   testthat::expect_equal(i,test)
#' }
as.link_fns.character = function(x, ...) {
  x = match.arg(
    x,
    c(
      "ident",
      "identity",
      "log",
      "logit",
      "probit",
      "cloglog",
      "neginv",
      "inv2",
      "1/mu^2"
    )
  )
  if (x %in% c("ident", "identity")) {
    return(new_link_fns(~.x, ~.x, c(-Inf, Inf), name = "I"))
  }
  if (x == "log") {
    return(new_link_fns(~ log(.x), ~ exp(.x), c(0, Inf), name = "log"))
  }
  if (x == "logit") {
    return(new_link_fns(
      stats::qlogis,
      ~ 1 / (1 + exp(-.x)),
      c(0, 1),
      name = "logit"
    ))
  }
  if (x == "probit") {
    return(new_link_fns(
      stats::qnorm,
      ~ stats::pnorm(.x),
      c(0, 1),
      name = "probit"
    ))
  }
  if (x == "cloglog") {
    return(new_link_fns(
      ~ log(-log(1 - .x)),
      ~ 1 - exp(-exp(.x)),
      c(0, 1),
      name = "cloglog"
    ))
  }
  if (x == "neginv") {
    return(new_link_fns(~ -1 / .x, ~ -1 / .x, c(0, Inf), name = "neginv"))
  }
  if (x %in% c("1/mu^2", "inv2")) {
    return(new_link_fns(~ 1 / .x^2, ~ sqrt(1 / .x), c(0, Inf), name = "inv2"))
  }
  stop("not a supported link type: ", x)
}

#' @export
#' @describeIn as.link_fns Link function from name
#' @concept link_fns_s3
#' @param x a statistical distribution as a `dist_fns` S3 object
#' @param ... ignored
as.link_fns.dist_fns = function(x, ...) {
  return(
    new_link_fns(
      carrier::crate(~ stats::qlogis(x$p(.x)), x = x),
      carrier::crate(~ x$q(1 / (1 + exp(-.x))), x = x),
      c(x$q(0), x$q(1)),
      name = x$name
    )
  )
}

#' @export
#' @describeIn as.link_fns Link function from name
#' @concept link_fns_s3
#' @param x a statistical family as a `stats::family` S3 object
#' @param ... ignored
as.link_fns.family = function(x, ...) {
  return(
    new_link_fns(
      x$linkfun,
      x$linkinv,
      c(x$linkinv(-Inf), x$linkinv(Inf)),
      name = x$family
    )
  )
}

#' @export
#' @describeIn as.link_fns Link function from support vector
#' @concept link_fns_s3
#' @param x a range of values that for the support
#' @param na.rm remove NAs when estimating mean and sd for data driven link
#'   functions
#' @param ... ignored
#' @unit
#' tmp = as.link_fns(c(0,10))
as.link_fns.numeric = function(x, ..., na.rm = TRUE) {
  if (na.rm) {
    x = x[!is.na(x)]
  }
  if (length(x) < 2) {
    stop(
      "support must be given as a non missing numeric vector of at least length 2."
    )
  }
  if (identical(x, c(0, 1)) || (all(x >= 0) && all(x <= 1))) {
    return(as.link_fns("logit"))
  }
  if (identical(x, c(0, Inf))) {
    return(as.link_fns("log"))
  }
  if (identical(x, c(-Inf, Inf))) {
    return(as.link_fns("identity"))
  }
  if (all(is.finite(x))) {
    if (length(x) == 2) {
      # A uniform on the real numbers.
      minx = min(x)
      deltax = max(x) - minx
      return(new_link_fns(
        support = c(minx, minx + deltax),
        trans = rlang::inject(~ stats::qlogis((.x - !!minx) / !!deltax)),
        inv = rlang::inject(~ (1 / (1 + exp(-.x))) * !!deltax + !!minx),
        name = "uniform"
      ))
    } else {
      mu = mean(x)
      sigma = stats::sd(x)
      return(new_link_fns(
        support = c(-Inf, Inf),
        trans = rlang::inject(~ (.x - !!mu) / !!sigma),
        inv = rlang::inject(~ (.x * !!sigma) + !!mu),
        name = "z"
      ))
    }
  }
  stop("Undefined support: ", range(x))
}

#' @param x a `link_fns` S3 class
#' @returns a numeric or other order-able item
#' @noRd
.sort_by_link_fns = function(x) {
  stop("link_fns is not sortable.")
}

# Boilerplate generated functions ----

# S3 classes can be used in a  number of styles as described in the `vctrs`
# package. This template provides some basic infrastructure for creating an S3
# `scalar` class style. This is centred around a list of unequal length data, or
# functions, like the output of base `stats::lm`. To make these work in data
# frames we need an ancillary list class that allows the object to be
# incorporated into data frames or operated on by `purrr`. These objects are not
# obviously useful in operations like addition etc., and are just dumb
# structured data holders that behave approximately predictably when combined
# into lists. The list classes are sortable and subset-able.

# S3 link_fns class ----

#' Check if this is a `link_fns` S3 object
#' @export
#' @param x anything
#' @returns TRUE or FALSE
#' @concept link_fns_s3
is.link_fns = function(x) {
  return(inherits(x, "link_fns"))
}

#'  Check if this is a `link_fns_list` S3 object
#' @param x anything
#' @returns TRUE or FALSE
#' @export
#' @concept link_fns_s3
is.link_fns_list = function(x) {
  inherits(x, "link_fns_list")
}

#' @inherit s3_link_fns
#' @export
#' @returns a `link_fns` S3 object
#' @concept link_fns_s3
as.link_fns = function(x, ...) {
  if (missing(x)) {
    return(new_link_fns())
  }
  if (is.link_fns(x)) {
    return(x)
  }
  UseMethod("as.link_fns", x)
}

#' Concatenate a `link_fns` S3 object or `link_fns_list`s
#' @param ... some of `link_fns`, `link_fns_list`s or lists of `link_fns`
#' @returns a `link_fns_list`
#' @concept link_fns_s3
#' @export
c.link_fns = function(...) {
  dots = rlang::list2(...)
  if (length(dots) == 0) {
    return(as.link_fns_list(NULL))
  }
  dots[[1]] = as.link_fns_list(dots[[1]])
  return(do.call(c.link_fns_list, dots))
}

#' Apply a function to each element of a vector returning a `link_fns_list`
#'
#' Analogous to `purrr::map_dbl()`
#'
#' @inheritParams purrr::map
#' @param .f a function to apply that returns a `link_fns` S3 object (usually an
#'   ``as.link_fns()`` call)
#' @seealso [purrr::map()]
#'
#' @returns a `link_fns_list`
#' @export
#' @concept link_fns_s3
map_link_fns = function(.x, .f, ..., .progress = FALSE) {
  # This will flatten any nested link_fns_lists. This is good as .f may return a
  # single link_fns or more likely a 1 element link_fns_list.
  return(purrr::map(.x, .f, ..., .progress = .progress) %>% as.link_fns_list())
}

#' Map over two inputs returning a `link_fns_list`
#'
#' Analogous to `purrr::map2_dbl()`
#'
#' @inheritParams purrr::map2
#' @param .f a function to apply to each `.x`, `.y` pair that returns a `link_fns`
#'   S3 object (usually an ``as.link_fns()`` call)
#' @seealso [purrr::map2()]
#'
#' @returns a `link_fns_list`
#' @export
#' @concept link_fns_s3
map2_link_fns = function(.x, .y, .f, ..., .progress = FALSE) {
  return(
    purrr::map2(.x, .y, .f, ..., .progress = .progress) %>% as.link_fns_list()
  )
}

#' Map over multiple inputs returning a `link_fns_list`
#'
#' Analogous to `purrr::pmap_dbl()`
#'
#' @inheritParams purrr::pmap
#' @param .f a function to apply to each `.l` item (usually an ``as.link_fns()`` call)
#' @seealso [purrr::map()]
#' @returns a `link_fns_list`
#' @export
#' @concept link_fns_s3
pmap_link_fns = function(.l, .f, ..., .progress = FALSE) {
  return(
    purrr::pmap(
      .l,
      .f,
      ...,
      .progress = .progress
    ) %>%
      as.link_fns_list()
  )
}

#' Create an empty `link_fns_list`
#' @inherit s3_link_fns_common
#' @export
#' @returns an empty `link_fns_list`
#' @concept link_fns_s3
link_fns = function() {
  return(as.link_fns_list(NULL))
}

## Utility functions ----

# removes this class from the object - internal use
.unclass_link_fns = function(x) {
  class(x) <- setdiff(class(x), "link_fns")
  return(x)
}

# x is a list but not a link_fns. This means it is a plain list
# or a link_fns_list
.is_list_excl_link_fns = function(x) {
  if (!is.list(x)) {
    return(FALSE)
  }
  if (is.link_fns(x)) {
    return(FALSE)
  }
  return(TRUE)
}

## Hidden exported functions ----

#' `link_fns` S3 Class operations
#'
#' Boilerplate S3 class operation
#'
#' @param x a `link_fns` S3 object
#' @param ... passed onto methods
#' @name s3_link_fns_common
#' @keywords internal
NULL


#' Default method throws error
#' @export
#' @inherit s3_link_fns_common
#' @returns nothing
#' @concept link_fns_s3
#' @keywords internal
as.link_fns.default = function(x, ...) {
  if (is.link_fns(x)) {
    return(x)
  }
  stop("Don't know how to convert a `", class(x)[[1]], "` to a `link_fns`.")
}

#' Cast a `link_fns` S3 object to a character vector
#' @inherit s3_link_fns_common
#' @export
#' @returns a character vector
#' @concept link_fns_s3
#' @keywords internal
as.character.link_fns = function(x, ...) {
  return(format(x, ...))
}

#' Print a `link_fns` S3 object
#' @inherit s3_link_fns_common
#' @export
#' @returns nothing
#' @concept link_fns_s3
#' @keywords internal
print.link_fns = function(x, ...) {
  cat(suppressWarnings(format(x, ...)))
  invisible(NULL)
}

#' Print a `link_fns` S3 object in an Rd document
#' @exportS3Method knitr::knit_print link_fns
#' @inherit s3_link_fns_common
#' @returns an `as-is` knitr chunk
#' @concept link_fns_s3
#' @keywords internal
knit_print.link_fns = function(x, ...) {
  structure(format(x), class = "knit_asis")
}

#' `link_fns` S3 objects length is always 1
#' @export
#' @inherit s3_link_fns_common
#' @returns 1 always
#' @concept link_fns_s3
#' @keywords internal
length.link_fns = function(x, ...) {
  return(1)
}

#' Pillar type name
#' @exportS3Method pillar::type_sum link_fns
#' @inherit s3_link_fns_common
#' @returns a string
#' @concept link_fns_s3
#' @keywords internal
type_sum.link_fns = function(x, ...) {
  "lnkfn"
}


#' Extract named attribute from a `link_fns`
#' @inherit s3_link_fns_common
#' @param y item to retrieve
#' @returns an attribute value for `x`
#' @export
#' @concept link_fns_s3
#' @keywords internal
#' @name at.link_fns
`@.link_fns` = function(x, y) {
  if (is.character(y)) {
    ylab = y
  } else {
    ylab = deparse(substitute(y))
  }
  return(attr(x, ylab))
}

#' Support for auto suggests on `link_fns_list`s
#' @inherit s3_link_fns_common
#' @param pattern a regular expression
#' @returns the names of the attributes
#' @exportS3Method utils::.AtNames link_fns
#' @concept link_fns_s3
#' @keywords internal
.AtNames.link_fns = function(x, pattern) {
  return(utils::.DollarNames(attributes(x), pattern))
}


#' Repeat an `link_fns` S3 object
#' @inherit s3_link_fns_common
#' @inheritDotParams base::rep -x
#' @returns a `link_fns_list`
#' @export
#' @concept link_fns_s3
#' @keywords internal
rep.link_fns = function(x, ...) {
  rep(as.link_fns_list(x), ...)
}

#' Convert a `link_fns` S3 object into a plain list
#' @inherit s3_link_fns_common
#' @export
#' @returns the internal structure of the object as a plain list
#' @concept link_fns_s3
#' @keywords internal
as.list.link_fns = function(x, ...) {
  .unclass_link_fns(x)
}

# S3 link_fns_list class ----

## Hidden exported functions ----

#' Manipulate `link_fns` S3 object lists
#'
#' These boilerplate functions allow generic list behaviour from `link_fns_list`
#' classes allowing `link_fns` S3 objects to be used in lists or dataframes.
#'
#' @param x a `link_fns_list` S3 object
#' @param ... passed onto methods
#'
#' @name s3_link_fns_list
#' @keywords internal
NULL

#' Un format the `link_fns_list`
#' @inherit s3_link_fns_list
#' @export
#' @concept link_fns_s3
#' @keywords internal
#' a plain list of `link_fns` S3 objects
as.list.link_fns_list = function(x, ...) {
  unclass(x)
}

#' Length of a `link_fns_list`
#' @inherit s3_link_fns_list
#' @export
#' @returns the length
#' @concept link_fns_s3
#' @keywords internal
length.link_fns_list = function(x, ...) {
  return(length(unclass(x)))
}


#' Cast to a list of `link_fns` S3 objects
#'
#' This function wraps `link_fns` and unwraps plain lists such that
#' the result is a flat `link_fns_list` containing `link_fns` objects only
#'
#' @inherit s3_link_fns_list
#' @return a `link_fns_list` S3 object
#' @export
#' @concept link_fns_s3
#' @keywords internal
as.link_fns_list = function(x) {
  if (length(unlist(x)) == 0) {
    # .class may be asserted when creating zero size / NULL `link_fns`s
    return(structure(list(), class = c("link_fns_list", "list")))
  }
  if (is.link_fns(x)) {
    return(structure(list(x), class = c("link_fns_list", "list")))
  }
  if (is.list(x)) {
    # x is a list or link_fns_list (but cannot be a single link_fns at this point)
    while (any(sapply(x, .is_list_excl_link_fns))) {
      # if there are any nested link_fns_lists or plain lists we will collapse
      # them . A link_fns_list must be a list of link_fnss without hierarchy.
      # We also have to make sure that plain link_fnss are wrapped
      x = lapply(x, as.link_fns_list)
      x = unlist(x, recursive = FALSE)
    }
    return(structure(x, class = c("link_fns_list", "list")))
  }

  stop(
    "Not convertible to a `link_fns_list` x is not `link_fns_list`, a `link_fns` or a uniform list of `link_fns`s",
    call. = FALSE
  )
}

#' Format a `link_fns_list`
#' @inherit s3_link_fns_list
#' @export
#' @returns a character vector for the list
#' @concept link_fns_s3
#' @keywords internal
format.link_fns_list = function(x, ...) {
  unlist(lapply(x, format))
}

#' Print a `link_fns_list`
#' @inherit s3_link_fns_list
#' @export
#' @returns nothing
#' @concept link_fns_s3
#' @keywords internal
print.link_fns_list = function(x, ...) {
  cat(sprintf("link_fns(%s)\n", length(x)))
  cat(suppressWarnings(format.link_fns_list(x, ...)), "\n")
  invisible(NULL)
}

#' Convert a `link_fns_list` to character
#' @inherit s3_link_fns_list
#' @export
#' @returns a character vector
#' @concept link_fns_s3
#' @keywords internal
as.character.link_fns_list = function(x, ...) {
  format.link_fns_list(x, ...)
}

#' Pillar type name
#' @inherit s3_link_fns_list
#' @exportS3Method pillar::type_sum link_fns_list
#' @concept link_fns_s3
#' @returns a name
#' @keywords internal
type_sum.link_fns_list = function(x, ...) {
  I(sprintf("<%s[]>", "lnkfn"))
}

#' Pillar shaft function
#' @inherit s3_link_fns_list
#' @returns a pillar shaft
#' @exportS3Method pillar::pillar_shaft
#' @concept link_fns_s3
#' @keywords internal
pillar_shaft.link_fns_list <- function(x, ...) {
  out <- format.link_fns_list(x, ...)
  pillar::new_pillar_shaft_simple(out, align = "right")
}

#' Concatenate or construct a `link_fns_list`
#'
#' @param ... some of `link_fns_list` and `link_fns` or list of `link_fns`s
#' @returns a flattened `link_fns_list` S3 object
#' @export
#' @concept link_fns_s3
#' @keywords internal
c.link_fns_list = function(...) {
  dots = rlang::list2(...)
  if (is.link_fns_list(dots)) {
    return(dots)
  }
  if (length(dots) == 1) {
    return(as.link_fns_list(dots))
  }
  # remove empty items
  dots = dots[sapply(dots, length) > 0]
  # make sure all list entries are a link_fns list (dots is list of link_fns_list)
  tmp = lapply(dots, as.link_fns_list)
  # convert to plain list of lists
  tmp = lapply(tmp, as.list.link_fns_list)
  # collapse one level
  tmp = unlist(tmp, recursive = FALSE)
  # convert to link_fns_list. this should throw an error if types are mixed.
  return(as.link_fns_list(tmp))
}

#' Repeat a `link_fns_list`
#' @inherit s3_link_fns_list
#' @inheritDotParams base::rep -x
#' @returns a `link_fns_list` S3 object
#' @concept link_fns_s3
#' @export
#' @keywords internal
rep.link_fns_list = function(x, ...) {
  tmp = NextMethod()
  return(as.link_fns_list(tmp))
}


#' Sort a `link_fns_list`
#' @inherit s3_link_fns_list
#' @param decreasing reverse the sort order
#' @returns an ordered `link_fns_list` S3 object
#' @export
#' @concept link_fns_s3
#' @keywords internal
sort.link_fns_list = function(x, decreasing = FALSE, ...) {
  indx = order(unlist(sapply(x, .sort_by_link_fns)))
  if (decreasing) {
    indx = rev(indx)
  }
  return(x[indx])
}

### link_fns_list Subsetting functions ----

#' Extract named item(s) from a `link_fns_list`
#' @inherit s3_link_fns_list
#' @param y item to retrieve
#' @returns a list or vector of the named items
#' @export
#' @concept link_fns_s3
#' @keywords internal
`$.link_fns_list` = function(x, y) {
  if (is.character(y)) {
    ylab = y
  } else {
    ylab = deparse(substitute(y))
  }
  if (length(x) == 1) {
    return(x[[1]][[ylab]])
  }
  return(sapply(seq_along(x), function(i) x[[i]][[ylab]], USE.NAMES = FALSE))
}

#' Support for auto suggests on `link_fns_list`s
#' @inherit s3_link_fns_list
#' @returns the names of the children
#' @exportS3Method utils::.DollarNames link_fns_list
#' @concept link_fns_s3
#' @keywords internal
.DollarNames.link_fns_list = function(x, pattern) {
  if (length(x) == 0) {
    return(character())
  }
  return(utils::.DollarNames(x[[1]], pattern))
}

#' Extract named item(s) from a `link_fns_list`
#' @inherit s3_link_fns_list
#' @param y attribute to retrieve
#' @returns a vector or list of the underlying `link_fns` attribute values
#' @export
#' @concept link_fns_s3
#' @keywords internal
#' @name at.link_fns_list
`@.link_fns_list` = function(x, y) {
  if (is.character(y)) {
    ylab = y
  } else {
    ylab = deparse(substitute(y))
  }
  if (length(x) == 1) {
    return(attr(x[[1]], ylab))
  }
  return(unname(sapply(
    seq_along(x),
    function(i) attr(x[[i]], ylab),
    USE.NAMES = FALSE
  )))
}

#' Support for auto suggests on `link_fns_list`s
#' @inherit s3_link_fns_list
#' @returns the names of the attributes
#' @exportS3Method utils::.AtNames link_fns_list
#' @concept link_fns_s3
#' @keywords internal
.AtNames.link_fns_list = function(x, pattern) {
  if (length(x) == 0) {
    return(character())
  }
  return(utils::.DollarNames(attributes(x[[1]]), pattern))
}

#' Subset a `link_fns_list`
#' @inherit s3_link_fns_list
#' @returns a `link_fns_list` S3 object
#' @export
#' @concept link_fns_s3
#' @keywords internal
`[.link_fns_list` = function(x, ...) {
  y = `[`(unclass(x), ...)
  return(as.link_fns_list(y))
}

#' Assign a subset to a `link_fns_list`
#' @inherit s3_link_fns_list
#' @param value the value as `link_fns_list` or `link_fns` S3 objects
#' @returns the updated `link_fns_list` S3 object
#' @export
#' @concept link_fns_s3
#' @keywords internal
`[<-.link_fns_list` = function(x, ..., value) {
  if (!is.link_fns_list(value) && !is.link_fns(value)) {
    stop(
      "cannot add a `",
      class(value)[[1]],
      "` to a `link_fns_list`"
    )
  }
  y = `[<-`(unclass(x), ..., value)
  return(as.link_fns_list(y))
}

#' get a value from a `link_fns_list`
#' @inherit s3_link_fns_list
#' @returns a `link_fns` S3 object
#' @export
#' @concept link_fns_s3
#' @keywords internal
`[[.link_fns_list` = function(x, ...) {
  y = `[[`(unclass(x), ...)
  return(y)
}

#' set a single value in a `link_fns_list`
#' @inherit s3_link_fns_list
#' @param value the value
#' @returns the updated `link_fns_list` S3 object
#' @export
#' @concept link_fns_s3
#' @keywords internal
`[[<-.link_fns_list` = function(x, ..., value) {
  if (is.link_fns_list(value) && length(value) == 1) {
    value = value[[1]]
  }
  if (!is.link_fns(value)) {
    stop(
      "cannot add a `",
      class(value)[[1]],
      "` to a `link_fns_list`"
    )
  }
  y = `[[<-`(unclass(x), ..., value)
  return(as.link_fns_list(y))
}
