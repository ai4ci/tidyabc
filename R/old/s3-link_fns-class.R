# Templated file: may be overwritten
# Generated by: pkgtools from `template-struct.R`
# ----------------------------------------------------------------------

# ---
# destfile: template-link_fns-class.R
# last-updated: 2024-03-24
# license: https://unlicense.org
# imports:
#    - knitr
#    - pillar
#    - purrr
#    - rlang
#    - utils
# ---

#' `link_fns` S3 Class operations
#'
#' An S3 link function allows forwards and backwards transformation.
#' Link functions can be defined by name or using a statistical distribution
#' in which case the forward link is a logit of the cumulative probability
#' and the reverse is the quantile of the expit.
#'
#' @param x a `link_fns` S3 object
#' @param ... passed onto methods
#' @name s3_link_fns
NULL

#' @describeIn s3_link_fns Create a new `link_fns` S3 object
#' @param trans the forward transforming function
#' @param inv the reverse inverting function
#' @param domain the domain or support of the link
#' @param range the range of the link (typically `-Inf` to `Inf`)
#' @returns a new `link_fns` S3 object
#' @keywords internal
#' @concept link_fns_s3
new_link_fns = function(trans, inv, domain, range = c(-Inf, Inf)) {
  stopifnot(length(domain) == 2, length(range) == 2)
  return(structure(
    list(
      trans = rlang::as_function(trans),
      inv = rlang::as_function(inv),
      domain = domain,
      range = range
    ),
    class = c("link_fns")
  ))
}

#' @describeIn s3_link_fns Format a `link_fns` S3 object
#' @export
#' @keywords internal
#' @returns a character value
#' @concept link_fns_s3
format.link_fns = function(x, ...) {
  return(sprintf("link: domain [%1.3g, %1.3g]", x$domain[1], x$domain[2]))
}

#' @export
#' @concept link_fns_s3
#' @param x one of "ident", "log", "logit", "probit", "cloglog", "neginv", "inv2"
#' @param ... ignored
#'
#' @unit
#' links = c("ident", "log", "logit", "probit", "cloglog", "neginv", "inv2")
#' test = seq(0.1,0.9,0.1) # within support of all links
#' for (l in links) {
#'   lfn = as.link_fns(l)
#'   t = lfn$trans(test)
#'   i = lfn$inv(t)
#'   testthat::expect_equal(i,test)
#' }
as.link_fns.character = function(x, ...) {
  x = match.arg(
    x,
    c("ident", "log", "logit", "probit", "cloglog", "neginv", "inv2")
  )
  if (x == "ident") {
    return(new_link_fns(~.x, ~.x, c(-Inf, Inf)))
  }
  if (x == "log") {
    return(new_link_fns(log, exp, c(0, Inf)))
  }
  if (x == "logit") {
    return(new_link_fns(stats::qlogis, ~ 1 / (1 + exp(-.x)), c(0, 1)))
  }
  if (x == "probit") {
    return(new_link_fns(stats::qnorm, stats::pnorm, c(0, 1)))
  }
  if (x == "cloglog") {
    return(new_link_fns(~ log(-log(1 - .x)), ~ 1 - exp(-exp(.x)), c(0, 1)))
  }
  if (x == "neginv") {
    return(new_link_fns(~ -1 / .x, ~ -1 / .x, c(0, Inf)))
  }
  if (x == "inv2") {
    return(new_link_fns(~ 1 / .x^2, ~ sqrt(1 / .x), c(0, Inf)))
  }
  stop("not a supported link type: ", x)
}

#' @export
#' @concept link_fns_s3
#' @param x a statistical distribution as a `dist_fns` S3 object
#' @param ... ignored
as.link_fns.dist_fns = function(x, ...) {
  return(
    new_link_fns(
      ~ stats::qlogis(x$p(.x)),
      ~ x$q(1 / (1 + exp(-.x))),
      c(x$q(0), x$q(1))
    )
  )
}


#' @param x a `link_fns` S3 class
#' @returns a numeric or other orderable item
#' @noRd
.order_link_fns = function(x) {
  stop("ordering not supported.")
}


# S3 link_fns class ----

#' @describeIn s3_link_fns_list Create an empty `link_fns_list`
#' @export
#' @returns an empty `link_fns_list`
#' @concept link_fns_s3
link_fns = function() {
  return(as.link_fns_list(NULL))
}

# removes this class from the object - internal use
.unclass_link_fns = function(x) {
  class(x) <- setdiff(class(x), "link_fns")
  return(x)
}


#' @describeIn s3_link_fns Cast to a `link_fns`
#' @export
#' @returns a `link_fns` S3 object
#' @concept link_fns_s3
as.link_fns = function(x, ...) {
  UseMethod("as.link_fns", x)
}

#' @export
#' @concept link_fns_s3
as.link_fns.default = function(x, ...) {
  if (is.link_fns(x)) {
    return(x)
  }
  stop("Don't know how to convert a `", class(x)[[1]], "` to a `link_fns`.")
}

#' @describeIn s3_link_fns Cast a `link_fns` S3 object to a character vector
#' @export
#' @keywords internal
#' @returns a character vector
#' @concept link_fns_s3
as.character.link_fns = function(x, ...) {
  return(format(x, ...))
}

#' @describeIn s3_link_fns Print a `link_fns` S3 object
#' @export
#' @keywords internal
#' @returns nothing
#' @concept link_fns_s3
print.link_fns = function(x, ...) {
  cat(suppressWarnings(format(x, ...)))
  invisible(NULL)
}

#' @describeIn s3_link_fns Print a `link_fns` S3 object in an Rd document
#' @exportS3Method knitr::knit_print link_fns
#' @keywords internal
#' @returns an `as-is` knitr chunk
#' @concept link_fns_s3
knit_print.link_fns = function(x, ...) {
  structure(format(x), class = "knit_asis")
}

#' @describeIn s3_link_fns `link_fns` S3 objects length is always 1
#' @export
#' @keywords internal
#' @returns 1 always
#' @concept link_fns_s3
length.link_fns = function(x, ...) {
  return(1)
}

#' @exportS3Method pillar::type_sum link_fns
type_sum.link_fns = function(x, ...) {
  abbreviate("link_fns", 3)
}

#' @describeIn s3_link_fns Check is a `link_fns` S3 object
#' @export
#' @returns TRUE or FALSE
#' @concept link_fns_s3
is.link_fns = function(x) {
  return(inherits(x, "link_fns"))
}

#' @describeIn s3_link_fns Extract named attribute from a `link_fns`
#' @param y item to retrieve
#' @returns an attribute value for `x`
#' @export
`@.link_fns` = function(x, y) {
  if (is.character(y)) {
    ylab = y
  } else {
    ylab = deparse(substitute(y))
  }
  return(attr(x, ylab))
}

#' @describeIn s3_link_fns Support for auto suggests on `link_fns_list`s
#' @param pattern a regular expression
#' @returns the names of the attributes
#' @export
.AtNames.link_fns = function(x, pattern) {
  return(.DollarNames(attributes(x), pattern))
}

#' @describeIn s3_link_fns Concatenate a `link_fns` S3 object or `link_fns_list`s
#' @param ... some of `link_fns`, `link_fns_list`s or lists of `link_fns`
#' @returns a `link_fns_list`
#' @export
c.link_fns = function(...) {
  dots = rlang::list2(...)
  if (length(dots) == 0) {
    return(as.link_fns_list(NULL))
  }
  dots[[1]] = as.link_fns_list(dots[[1]])
  return(do.call(c.link_fns_list, dots))
}

#' @describeIn s3_link_fns Repeat an `link_fns` S3 object
#' @returns a `link_fns_list`
#' @export
rep.link_fns = function(x, ...) {
  rep(as.link_fns_list(x), ...)
}

#' @describeIn s3_link_fns Convert a `link_fns` S3 object into a plain list
#' @export
#' @returns the internal structure of the object as a plain list
#' @concept link_fns_s3
as.list.link_fns = function(x, ...) {
  .unclass_link_fns(x)
}

# S3 link_fns_list class ----

#' Manipulate `link_fns` S3 object lists
#'
#' These functions allow generic list behaviour.
#'
#' @param x a `link_fns_list` S3 object
#' @param ... passed onto methods
#'
#' @concept link_fns_s3
#' @name s3_link_fns_list
NULL

#' @describeIn s3_link_fns_list Unformat the `link_fns_list`
#' @export
#' @concept link_fns_s3
#' a plain list of `link_fns` S3 objects
as.list.link_fns_list = function(x, ...) {
  unclass(x)
}

#' @describeIn s3_link_fns_list Length of a `link_fns_list`
#' @export
#' @returns the length
#' @concept link_fns_s3
length.link_fns_list = function(x, ...) {
  return(length(unclass(x)))
}

#' @describeIn s3_link_fns_list Check is a `link_fns_list`
#' @export
#' @concept link_fns_s3
is.link_fns_list = function(x) {
  inherits(x, "link_fns_list")
}

# x is a list but not a link_fns. This means it is a plain list
# or a link_fns_list
.is_list_excl_link_fns = function(x) {
  if (!is.list(x)) {
    return(FALSE)
  }
  if (is.link_fns(x)) {
    return(FALSE)
  }
  return(TRUE)
}

#' Cast to a list of `link_fns` S3 objects
#'
#' This function wraps `link_fns` and unwraps plain lists such that
#' the result is a flat `link_fns_list` containing `link_fns` objects only
#'
#' @param x a list
#' @return a `link_fns_list` S3 object
#' @export
#' @concept link_fns_s3
as.link_fns_list = function(x) {
  if (length(unlist(x)) == 0) {
    # .class may be asserted when creating zero size / NULL `link_fns`s
    return(structure(list(), class = c("link_fns_list", "list")))
  }
  if (is.link_fns(x)) {
    return(structure(list(x), class = c("link_fns_list", "list")))
  }
  if (is.list(x)) {
    # x is a list or link_fns_list (but cannot be a single link_fns at this point)
    while (any(sapply(x, .is_list_excl_link_fns))) {
      # if there are any nested link_fns_lists or plain lists we will collapse
      # them . A link_fns_list must be a list of link_fnss without hierarchy.
      # We also have to make sure that plain link_fnss are wrapped
      x = lapply(x, as.link_fns_list)
      x = unlist(x, recursive = FALSE)
    }
    return(structure(x, class = c("link_fns_list", "list")))
  }

  stop(
    "Not convertible to a `link_fns_list` x is not `link_fns_list`, a `link_fns` or a uniform list of `link_fns`s",
    call. = FALSE
  )
}

#' @describeIn s3_link_fns_list Format a `link_fns_list`
#' @export
#' @returns a character vector for the list
#' @concept link_fns_s3
format.link_fns_list = function(x, ...) {
  unlist(lapply(x, format))
}

#' @describeIn s3_link_fns_list Print a `link_fns_list`
#' @export
#' @returns nothing
#' @concept link_fns_s3
print.link_fns_list = function(x, ...) {
  cat(sprintf("link_fns(%s)\n", length(x)))
  cat(suppressWarnings(format.link_fns_list(x, ...)), "\n")
  invisible(NULL)
}

#' @describeIn s3_link_fns_list Convert a `link_fns_list` to character
#' @export
#' @returns a character vector
#' @concept link_fns_s3
as.character.link_fns_list = function(x, ...) {
  format.link_fns_list(x, ...)
}

#' @exportS3Method pillar::type_sum link_fns_list
#' @concept link_fns_s3
type_sum.link_fns_list = function(x, ...) {
  I(sprintf("<%s[]>", abbreviate("link_fns", 3, named = FALSE)))
}

#' @exportS3Method pillar::pillar_shaft
#' @concept link_fns_s3
pillar_shaft.link_fns_list <- function(x, ...) {
  out <- format.link_fns_list(x, ...)
  pillar::new_pillar_shaft_simple(out, align = "right")
}

#' @describeIn s3_link_fns_list Concatenate or construct a `link_fns_list`
#' @param ... some of `link_fns_list` and `link_fns` or list of `link_fns`s
#' @returns a fully flattened `link_fns_list` S3 object
#' @export
c.link_fns_list = function(...) {
  dots = rlang::list2(...)
  if (is.link_fns_list(dots)) {
    return(dots)
  }
  if (length(dots) == 1) {
    return(as.link_fns_list(dots))
  }
  # remove empty items
  dots = dots[sapply(dots, length) > 0]
  # make sure all list entries are a link_fns list (dots is list of link_fns_list)
  tmp = lapply(dots, as.link_fns_list)
  # convert to plain list of lists
  tmp = lapply(tmp, as.list.link_fns_list)
  # collapse one level
  tmp = unlist(tmp, recursive = FALSE)
  # convert to link_fns_list. this should throw an error if types are mixed.
  return(as.link_fns_list(tmp))
}

#' @describeIn s3_link_fns_list Repeat a `link_fns_list`
#' @export
rep.link_fns_list = function(x, ...) {
  tmp = NextMethod()
  return(as.link_fns_list(tmp))
}


#' @describeIn s3_link_fns_list Repeat a `link_fns_list`
#' @param decreasing reverse the sort order
#' @export
sort.link_fns_list = function(x, decreasing = FALSE, ...) {
  indx = order(unlist(sapply(x, .order_link_fns)))
  if (decreasing) {
    indx = rev(indx)
  }
  return(x[indx])
}

## link_fns_list Subsetting functions ----

#' @describeIn s3_link_fns_list Extract named item(s) from a `link_fns_list`
#' @param y item to retrieve
#' @export
`$.link_fns_list` = function(x, y) {
  if (is.character(y)) {
    ylab = y
  } else {
    ylab = deparse(substitute(y))
  }
  if (length(x) == 1) {
    return(x[[1]][[ylab]])
  }
  return(sapply(seq_along(x), function(i) x[[i]][[ylab]], USE.NAMES = FALSE))
}

#' Support for auto suggests on `link_fns_list`s
#' @keywords internal
#' @param x a `link_fns_list`
#' @returns the names of the children
#' @export
.DollarNames.link_fns_list = function(x, pattern) {
  if (length(x) == 0) {
    return(character())
  }
  return(.DollarNames(x[[1]], pattern))
}

#' @describeIn s3_link_fns_list Extract named item(s) from a `link_fns_list`
#' @param y attribute to retrieve
#' @returns a vector or list of the underlying `link_fns` attribute values
#' @export
`@.link_fns_list` = function(x, y) {
  if (is.character(y)) {
    ylab = y
  } else {
    ylab = deparse(substitute(y))
  }
  if (length(x) == 1) {
    return(attr(x[[1]], ylab))
  }
  return(unname(sapply(
    seq_along(x),
    function(i) attr(x[[i]], ylab),
    USE.NAMES = FALSE
  )))
}

#' Support for auto suggests on `link_fns_list`s
#' @keywords internal
#' @param x a `link_fns_list`
#' @returns the names of the attributes
#' @export
.AtNames.link_fns_list = function(x, pattern) {
  if (length(x) == 0) {
    return(character())
  }
  return(.DollarNames(attributes(x[[1]]), pattern))
}

#' @describeIn s3_link_fns_list Subset a `link_fns_list`
#' @returns a `link_fns_list` S3 object
#' @export
`[.link_fns_list` = function(x, ...) {
  y = `[`(unclass(x), ...)
  return(as.link_fns_list(y))
}

#' @describeIn s3_link_fns_list Assign a subset to a `link_fns_list`
#' @param value the value as `link_fns_list` or `link_fns` S3 objects
#' @returns the updated `link_fns_list` S3 object
#' @export
`[<-.link_fns_list` = function(x, ..., value) {
  if (!is.link_fns_list(value) && !is.link_fns(value)) {
    stop(
      "cannot add a `",
      class(value)[[1]],
      "` to a `link_fns_list`"
    )
  }
  y = `[<-`(unclass(x), ..., value)
  return(as.link_fns_list(y))
}

#' @describeIn s3_link_fns_list get a value from a `link_fns_list`
#' @returns a `link_fns` S3 object
#' @export
`[[.link_fns_list` = function(x, ...) {
  y = `[[`(unclass(x), ...)
  return(y)
}

#' @describeIn s3_link_fns_list set a single value in a `link_fns_list`
#' @param value the value
#' @returns the updated `link_fns_list` S3 object
#' @export
`[[<-.link_fns_list` = function(x, ..., value) {
  if (is.link_fns_list(value) && length(value) == 1) {
    value = value[[1]]
  }
  if (!is.link_fns(value)) {
    stop(
      "cannot add a `",
      class(value)[[1]],
      "` to a `link_fns_list`"
    )
  }
  y = `[[<-`(unclass(x), ..., value)
  return(as.link_fns_list(y))
}

#' Apply a function to each element of a vector returning a `link_fns_list`
#'
#' Analogous to `purrr::map_dbl()`
#'
#' @inheritParams purrr::map
#' @param .f a function to apply that returns a `link_fns` S3 object (usually an
#'   ``as.link_fns()`` call)
#' @seealso [purrr::map()]
#'
#' @returns a `link_fns_list`
#' @export
#' @concept link_fns_s3
map_link_fns = function(.x, .f, ..., .progress = FALSE) {
  # This will flatten any nested link_fns_lists. This is good as .f may return a
  # single link_fns or more likely a 1 element link_fns_list.
  return(purrr::map(.x, .f, ..., .progress = .progress) %>% as.link_fns_list())
}


#' Map over two inputs returning a `link_fns_list`
#'
#' Analogous to `purrr::map2_dbl()`
#'
#' @inheritParams purrr::map2
#' @param .f a function to apply to each `.x`, `.y` pair that returns a `link_fns`
#'   S3 object (usually an ``as.link_fns()`` call)
#' @seealso [purrr::map2()]
#'
#' @returns a `link_fns_list`
#' @export
#' @concept link_fns_s3
map2_link_fns = function(.x, .y, .f, ..., .progress = FALSE) {
  return(
    purrr::map2(.x, .y, .f, ..., .progress = .progress) %>% as.link_fns_list()
  )
}

#' Map over multiple inputs returning a `link_fns_list`
#'
#' Analogous to `purrr::pmap_dbl()`
#'
#' @inheritParams purrr::pmap
#' @param .f a function to apply to each `.l` item (usually an ``as.link_fns()`` call)
#' @seealso [purrr::map()]
#' @returns a `link_fns_list`
#' @export
#' @concept link_fns_s3
pmap_link_fns = function(.l, .f, ..., .progress = FALSE) {
  return(
    purrr::pmap(
      .l,
      .f,
      ...,
      .progress = .progress
    ) %>%
      as.link_fns_list()
  )
}
