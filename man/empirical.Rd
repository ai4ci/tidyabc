% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dist-empirical.R
\name{empirical}
\alias{empirical}
\title{Fit a piecewise logit transformed linear model to cumulative data}
\usage{
empirical(
  x,
  probs = NULL,
  link = "ident",
  knots = NULL,
  tail_p = 1e-05,
  weights = NULL,
  smooth = TRUE,
  name = NULL,
  ...
)
}
\arguments{
\item{x}{either a vector of samples from a distribution \code{X} or cut-offs for
cumulative probabilities when combined with \code{probs}}

\item{probs}{(optional) If present a vector the same length as x giving
\code{P(X <= x)}.}

\item{link}{a link function. Either as name, or a \code{link_fns} S3 object. In
the latter case this could be derived from a statistical distribution by
\verb{as.link_fns(<dist_fns>)}. This supports the use of a prior to define the
support of the empirical function, and is designed to prevent tail
truncation. Support for the updated quantile function will be the same as
the provided prior.}

\item{knots}{for distributions from data how many points do we use to model
the cdf? I recommend an uneven number, without a lot of data this will tend
to overfit 9 knots for 1000 samples seems OK, max 7 for 250, 5 for 100.
Less is usually more.}

\item{tail_p}{what is the minimum tail probability modelled.}

\item{weights}{if the distribution is from data then an importance weighting
for each point can be supplied here. This will be normalised, so it is a
relative importance with respect to the mean of the weights.}

\item{smooth}{fits the empirical distribution with a spline, and generates a
back-spline for the inverse, creating a mostly smooth density. This
smoothness comes at the price of potential over-fitting and will produce
small differences between \code{p} and \code{q} functions such that \code{x=p(q(x))} is no
longer exactly true. Setting this to false will replace this with a
piecewise linear fit that is not smooth in the density, but is exact in
forward and reverse transformation.}

\item{...}{not used}
}
\value{
a \code{dist_fns} S3 object containing 3 functions \code{p()} for CDF, \code{q()}
for quantile, and \code{r()} for a RNG, and \code{d()} for density. The density
function may be discontinuous.
}
\description{
This fits a CDF and quantile function to data in a transformed space. X value
transformation is specified in the \code{link} parameter and is either something
like "log", "logit", etc or can also be specified as the logit transformed cdf and quantile function from a statistical distribution.
}
\details{
The empirical distribution fitted is a piecewise linear or monotonically
increasing spline fit to data in transformed X and logit Y space. The end
points are linearly interpolated in this space to the \code{tail_p}th quantile.
The function can fit data provided either as samples in a vector of \code{x}, or
as quantiles specified as \verb{x, P(X<=x)} pairs.

This function imputes tails of distributions. Given perfect data as samples
or as quantiles it should recover the tail
}
\concept{empirical}

\section{Unit tests}{
\if{html}{\out{<div class="sourceCode">}}\preformatted{


#from cdf:
xs = c(2,3,6,9)
ps = c(0.1,0.4,0.6,0.95)
e = empirical(xs, ps, link="log")

testthat::expect_equal(e$p(xs), ps)
testthat::expect_equal(e$q(ps), xs)

# from samples:
withr::with_seed(123,{
 e2 = empirical(rnorm(10000),knots = 20)
 testthat::expect_equal(e2$p(-5:5), pnorm(-5:5), tolerance=0.01)
 testthat::expect_equal(e2$q(seq(0,1,0.1)), qnorm(seq(0,1,0.1)), tolerance=0.025)
})

p2 = seq(0,1,0.1)
testthat::expect_equal( e2$p(e2$q(p2)), p2, tolerance = 0.001)

# quantiles:
p = c(0.025,0.05,0.10,0.25,0.5,0.75,0.9,0.95,0.975)
q = stats::qgamma(p, shape=2)
shape2_gamma = as.dist_fns(pgamma, shape=2)
gemp = empirical(q,p,link = shape2_gamma)
withr::with_seed(123, {
  testthat::expect_equal(mean(gemp$r(100000)),2, tolerance=0.01)
  testthat::expect_equal(sd(gemp$r(100000)), sqrt(2), tolerance=0.01)
})

# With perfect input can recover the underlying distribution including tails:
tmp = empirical(x=seq(0.01,0.99,0.01),link = as.dist_fns(punif,0, 1), knots = 100)
testthat::expect_equal(
  tmp$q(c(0.01, 0.1, 0.25, 0.75, 0.9, 0.99)),
  c(0.01, 0.1, 0.25, 0.75, 0.9, 0.99),
  tolerance = 0.002
)

}\if{html}{\out{</div>}}
}

