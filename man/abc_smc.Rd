% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/workflow.R
\name{abc_smc}
\alias{abc_smc}
\title{Perform ABC sequential Monte Carlo fitting}
\usage{
abc_smc(
  obsdata,
  priors_list,
  sim_fn,
  scorer_fn,
  n_sims,
  acceptance_rate,
  kernel_t = 0.2,
  max_waves = ceiling(log(0.001)/log(acceptance_rate)),
  converged_fn = default_termination_fn(),
  obsscores = NULL,
  distance_method = "euclidean",
  seed = NULL,
  parallel = FALSE,
  allow_continue = interactive()
)
}
\arguments{
\item{obsdata}{The observational data. The data in this will typically
be a named list, but could be anything, e.g. dataframe. It is the reference
data that the simulation model is aiming to replicate.}

\item{priors_list}{a named list of priors specified as \code{dist_fns} (see
\code{as.dist_fns()}), plus optionally, derived values as unnamed 2-sided
formulae, where the LHS of the formula will be assigned to the value of the
RHS, plus optionally a set of constraints as one sided formulae where the
RHS of the formulae will resolve to a boolean value.}

\item{sim_fn}{a user defined function that takes a set of parameters named
the same as the list \code{priors}. It must return a simulated data set in the
same format as \code{obsdata}, or that can be compared to \code{simdata} by
\code{scorer_fn}. This function must not refer to global parameters, and will be
automatically crated with \code{carrier}.}

\item{scorer_fn}{a user supplied function that matches the following
signature \code{scorer_fn(simdata, obsdata, ....)}, i.e. it takes data in the
format of \code{simdata} paired with the original \code{obsdata} and returns a named
list of scores per simulation. This function can make use of the
\verb{calculate_*()} set of functions to compare components of the simulation to
the original data. This function must not refer to global parameters, and
will be automatically crated with \code{carrier}. If this is a purrr style
function then \code{.x} will refer to simulation output and \code{.y} to original
observation data.}

\item{acceptance_rate}{What proportion of simulations to keep in ABC rejection
or hard ABC parts of the algorithms.}

\item{kernel_t}{A kernel bandwidth parameter for proposals. This controls the
amount of noise that particles are perturbed by (and hence the spread of
the PDF of the proposal distribution), and 1 is approximately 34\% of the
proposal distribution at the centre. Smaller values (default is 0.2) give a
smaller step size in generating new proposals, and proposals will be closer
to currently accepted particles.}

\item{max_waves}{the maximum number of ABC iterations to do before admitting
defeat. The number of simulations executed will be \code{n_sims*max_waves}.
Fewer waves may be performed if the algorithm converges early.}

\item{converged_fn}{a function that takes a \code{summary} and \code{per_param} input
and generates a logical indicator that the function has converged}

\item{obsscores}{Summary scores for the observational data. This will
be a named list, and is equivalent to the output of \code{scorer_fn},
on the observed data. If not given typically it will be assumed to be all
zeros.}

\item{distance_method}{what metric is used to combine \code{simscores} and \code{obsscores}
and is one of \code{"euclidean"}, \code{"manhattan"}, or \code{"mahalanobis"}.}

\item{seed}{an optional random seed}

\item{parallel}{parallelise the simulation? If this is set to true then the
simulation step will be parallelised using \code{furrr}. For this to make any
difference it must have been set up with the following:
\code{future::plan(future::multisession, workers = parallel::detectCores()-2)}}

\item{allow_continue}{if SMC or adaptive algorithms have not converged after
\code{max_waves} allow the algorithm to interactively prompt the user to continue.}
}
\value{
a list containing 3 items. A flag assessing convergence, a list
of summary metrics for each wave (\code{waves}), and \code{posteriors} - the last
wave filtered parameter posteriors including component and summary score
columns, plus weights.
}
\description{
This function will execute a simulation for a random selection of parameters.
Based on the \code{acceptance_rate} it will reject a proportion of the results.
The remaining results are weighted (using a kernel with a tolerance
equivalent to half the acceptance rate). Weighted parameter particles
generate proposals for further waves but a particle perturbation. Waves
are executed until a maximum is reached or the results converge sufficiently
that the changes between waves are small. A relatively small number of
simulations may be attempted with a high acceptance rate, over multiple waves.
}
\examples{

fit = abc_smc(
  obsdata = example_obsdata(),
  priors_list = example_priors_list(),
  sim_fn = example_sim_fn,
  scorer_fn = example_scorer_fn,
  n_sims = 1000,
  acceptance_rate = 0.25,
  max_waves = 5,
  parallel = FALSE,
  allow_continue = FALSE
)

summary(fit)

}
\concept{workflow}
