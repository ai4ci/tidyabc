% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils-crate.R
\name{.autocrate}
\alias{.autocrate}
\title{Crate a function definition that may not have all the namespaces qualified.}
\usage{
.autocrate(
  .fn,
  ...,
  .parent_env = baseenv(),
  .error_arg = ".fn",
  .error_call = environment()
)
}
\arguments{
\item{.fn}{A fresh formula or function. "Fresh" here means that
they should be declared in the call to \code{crate()}. See examples if
you need to crate a function that is already defined. Formulas
are converted to purrr-like lambda functions using
\code{\link[rlang:as_function]{rlang::as_function()}}.}

\item{...}{Named arguments to declare in the environment of \code{.fn}.}

\item{.parent_env}{The default of \code{baseenv()} ensures that the evaluation
environment of the crate is isolated from the search path. Specifying
another environment such as the global environment allows this condition to
be relaxed (but at the expense of no longer being able to rely on a local
run giving the same results as one in a different process).}

\item{.error_arg}{An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.}

\item{.error_call}{The execution environment of a currently
running function, e.g. \code{caller_env()}. The function will be
mentioned in error messages as the source of the error. See the
\code{call} argument of \code{\link[rlang:abort]{abort()}} for more information.}
}
\value{
a crated function
}
\description{
Regular crating requires everything be namespaced and which is easy to
forget, particularly for \verb{stats::} and \verb{dplyr::}.
}
\keyword{internal}

\section{Unit tests}{
\if{html}{\out{<div class="sourceCode">}}\preformatted{


z = 13
tmp = .autocrate(function(x) {
  y <- runif(x)
  stats::rnorm(x,y)
  x[1] <- 12
  x[2] <- !!z # inlining happens during expression parsing...?
})

# unqualified reference is qualified
testthat::expect_equal(format(body(tmp)), c(
  "{",
  "    y <- stats::runif(x)",
  "    stats::rnorm(x, y)",
  "    x[1] <- 12",
  "    x[2] <- 13",
  "}"
))

tmpfn = function(x) {
  "temp"
}
tmpvar = 10

testthat::expect_error(
  {
    .autocrate(function(y) {
      if (tmpvar == 10) tmpfn(y)
    })
  },
  "References to undefined globals in function `.fn`: tmpvar,tmpfn",
  fixed = TRUE
)

with_ref = .autocrate(
  function(y) {
    if (tmpvar == 10) tmpfn(y)
  },
  tmpvar = tmpvar,
  tmpfn=tmpfn
)

testthat::expect_equal(
  ls(rlang::fn_env(with_ref)),
  c("tmpfn", "tmpvar")
)

library(dplyr)
# Global definitions in dplyr must be explicitly assigned like in .
a = .autocrate(function(x) {
  Species = NULL
  x %>% pull(Species) %>% head(5)
})

testthat::expect_equal(a(iris), structure(
  c(1L, 1L, 1L, 1L, 1L),
  levels = c("setosa", "versicolor", "virginica"),
  class = "factor"
))

# Autocrating is recursive on functions supplied as globals:
not_crated_fn = function(x) {rnorm(x); return("success")}

crated_fn = .autocrate(function(x) {
   generator(x)
}, generator = not_crated_fn)

tmp = format(body(rlang::fn_env(crated_fn)$generator))

testthat::expect_equal(
  tmp,
  c("{", "    stats::rnorm(x)", "    return(\"success\")", "}")
)


}\if{html}{\out{</div>}}
}

