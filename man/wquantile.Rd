% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dist-empirical.R
\name{wquantile}
\alias{wquantile}
\title{Quantile from weighted data with link function support}
\usage{
wquantile(p, x, w = NULL, link = "identity", names = TRUE, window = 7)
}
\arguments{
\item{p}{the probabilities for which to estimate quantiles from the data}

\item{x}{a set of observations}

\item{w}{for data fits, a vector the same length as \code{x} giving the
importance weight of each observation. This does not need to be normalised.
There must be some non zero weights, and all must be finite.}

\item{link}{a link function. Either as name, or a \code{link_fns} S3 object. In
the latter case this could be derived from a statistical distribution by
\verb{as.link_fns(<dist_fns>)}. This supports the use of a prior to define the
support of the empirical function, and is designed to prevent tail
truncation. Support for the updated quantile function will be the same as
the provided prior.}

\item{names}{name the resulting quantile vector}

\item{window}{the number of data points to include when estimating the
quantile. The closest \code{window} points are picked and used as a distance
weighted linear interpolation of the weighted CDF in logit-link space. This
tends to give good results for extrapolating tails.}
}
\value{
a vector of quantiles
}
\description{
This quantile function has different order of parameters from
base quantile. It takes a weight and a link function specification which
allows us to define the support of the quantile function. It is
optimised for imputing the tail of distributions and not speed.
}
\details{
The process involves:
\enumerate{
\item Link transformation: \eqn{x} values are transformed using the link function:
\eqn{x_1 = T(x)}.
\item Standardization: Transformed values are standardized:
\eqn{x_2 = \frac{x_1 - \mu_{w,1}}{\sigma_{w,1}}}, where \eqn{\mu_{w,1}} and
\eqn{\sigma_{w,1}} are the weighted mean and standard deviation of \eqn{x_1}.
\item Weighted CDF calculation: The empirical CDF \eqn{y} is calculated from weights \eqn{w}.
\item Logit transformation: \eqn{y} is transformed:
\eqn{y_2 = \text{logit}(y)}.
\item Local interpolation: For a target probability \eqn{p}, \eqn{p_2 = \text{logit}(p)}
is calculated. A window of \eqn{window} points is selected from the \eqn{(y_2, x_2)}
pairs around \eqn{p_2}. A weighted linear model is fitted using Gaussian kernel
weights based on distance in \eqn{y_2} space: \eqn{K = \exp(-\frac{1}{2} u^2)},
where \eqn{u} is the normalized distance.
\item Quantile estimation: The local model predicts \eqn{q_2} for \eqn{p_2}.
\item Back-transformation: The quantile is transformed back:
\eqn{q = T^{-1}(q_2 \cdot \sigma_{w,1} + \mu_{w,1})}.
}

This is a moderately expensive function to call (in memory terms), as it
needs to construct the whole quantile function. if there are multiple calls
consider using \code{empirical()} to build a quantile function and using that.
}
\examples{

# fit weighted data
samples = seq(0,10,0.01)
weights = dgamma2(samples, mean=5, sd=2)

wquantile(c(0.25,0.5,0.75), x = samples, w = weights, link="log")

# compared to the sampled distribution
qgamma2(c(0.25,0.5,0.75), mean=5, sd=2)

# unweighted:
wquantile(p = c(0.25,0.5,0.75), x = stats::rnorm(1000))
qnorm(p = c(0.25,0.5,0.75))


}
\concept{empirical}

\section{Unit tests}{
\if{html}{\out{<div class="sourceCode">}}\preformatted{


test = function(rfn,qfn, link,..., n = 100000, tol=1000/(n+10000)) {
  testthat::expect_equal(abs(
   unname(wquantile(c(0.025, 0.5, 0.975),rfn(100000,...),link=link,names=FALSE)-
    qfn(c(0.025, 0.5, 0.975), ...))
  ), c(0,0,0), tolerance=tol)
}

withr::with_seed(123, {

  test(stats::rnorm,stats::qnorm,"identity",n = 10000)
  test(stats::rnorm,stats::qnorm,"identity",mean=4,n = 10000)
  test(stats::rnorm,stats::qnorm,"identity",sd=3, n = 100000, tol=0.05)

  test(stats::rnorm,stats::qnorm,"identity",n = 5000)
  test(stats::rnorm,stats::qnorm,"identity",n = 1000)
  test(stats::rnorm,stats::qnorm,"identity",n = 100)
  test(stats::rnorm,stats::qnorm,"identity",n = 30)

  test(stats::rgamma,stats::qgamma,"log", 4,n = 10000)
  test(stats::rgamma,stats::qgamma,"log", 4,n = 5000)
  test(stats::rgamma,stats::qgamma,"log", 4,n = 1000)
  test(stats::rgamma,stats::qgamma,"log", 4, 3,n = 100)
  test(stats::rgamma,stats::qgamma,"log", 4,n = 30)

  test(stats::runif,stats::qunif,as.link_fns(c(0,10)),0,10)

})

}\if{html}{\out{</div>}}
}

